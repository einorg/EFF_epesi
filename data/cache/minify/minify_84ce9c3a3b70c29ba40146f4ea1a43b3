/**
* Copyright 2012 Tsvetan Tsvetkov
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Author: Tsvetan Tsvetkov (tsekach@gmail.com)
*/
(function (win) {
	/*
	Safari native methods required for Notifications do NOT run in strict mode.
	*/
	//"use strict";
	var PERMISSION_DEFAULT = "default",
	PERMISSION_GRANTED = "granted",
	PERMISSION_DENIED = "denied",
	PERMISSION = [PERMISSION_GRANTED, PERMISSION_DEFAULT, PERMISSION_DENIED],
	defaultSetting = {
		pageVisibility: false,
		autoClose: 0
	},
	empty = {},
	emptyString = "",
	isSupported = (function () {
		var isSupported = false;
		/*
		* Use try {} catch() {} because the check for IE may throws an exception
		* if the code is run on browser that is not Safar/Chrome/IE or
		* Firefox with html5notifications plugin.
		*
		* Also, we canNOT detect if msIsSiteMode method exists, as it is
		* a method of host object. In IE check for existing method of host
		* object returns undefined. So, we try to run it - if it runs
		* successfully - then it is IE9+, if not - an exceptions is thrown.
		*/
		try {
			isSupported = !!(/* Safari, Chrome */win.Notification || /* Chrome & ff-html5notifications plugin */win.webkitNotifications || /* Firefox Mobile */navigator.mozNotification || /* IE9+ */(win.external && win.external.msIsSiteMode() !== undefined));
		} catch (e) {}
		return isSupported;
	}()),
	ieVerification = Math.floor((Math.random() * 10) + 1),
	isFunction = function (value) { return (value && (value).constructor === Function); },
	isString = function (value) {return (value && (value).constructor === String); },
	isObject = function (value) {return (value && (value).constructor === Object); },
	/**
	* Dojo Mixin
	*/
	mixin = function (target, source) {
		var name, s;
		for (name in source) {
			s = source[name];
			if (!(name in target) || (target[name] !== s && (!(name in empty) || empty[name] !== s))) {
				target[name] = s;
			}
		}
		return target; // Object
	},
	noop = function () {},
	settings = defaultSetting;
	function getNotification(title, options) {
		var notification;
		if (win.Notification) { /* Safari 6, Chrome (23+) */
			notification = new win.Notification(title, {
				/* The notification's icon - For Chrome in Windows, Linux & Chrome OS */
				icon: isString(options.icon) ? options.icon : options.icon.x32,
				/* The notification�s subtitle. */
				body: options.body || emptyString,
				/*
				The notification�s unique identifier.
				This prevents duplicate entries from appearing if the user has multiple instances of your website open at once.
				*/
				tag: options.tag || emptyString
			});
		} else if (win.webkitNotifications) { /* FF with html5Notifications plugin installed */
			notification = win.webkitNotifications.createNotification(options.icon, title, options.body);
			notification.show();
		} else if (navigator.mozNotification) { /* Firefox Mobile */
			notification = navigator.mozNotification.createNotification(title, options.body, options.icon);
			notification.show();
		} else if (win.external && win.external.msIsSiteMode()) { /* IE9+ */
			//Clear any previous notifications
			win.external.msSiteModeClearIconOverlay();
			win.external.msSiteModeSetIconOverlay((isString(options.icon) ? options.icon : options.icon.x16), title);
			win.external.msSiteModeActivate();
			notification = {
			"ieVerification": ieVerification + 1
			};
		}
		return notification;
	}
	function getWrapper(notification) {
		return {
			close: function () {
				if (notification) {
					if (notification.close) {
						//http://code.google.com/p/ff-html5notifications/issues/detail?id=58
						notification.close();
					}
					else if (notification.cancel) {
						notification.cancel();
					} else if (win.external && win.external.msIsSiteMode()) {
						if (notification.ieVerification === ieVerification) {
							win.external.msSiteModeClearIconOverlay();
						}
					}
				}
			}
		};
	}
	function requestPermission(callback) {
		if (!isSupported) { return; }
		var callbackFunction = isFunction(callback) ? callback : noop;
		if (win.webkitNotifications && win.webkitNotifications.checkPermission) {
			/*
			* Chrome 23 supports win.Notification.requestPermission, but it
			* breaks the browsers, so use the old-webkit-prefixed
			* win.webkitNotifications.checkPermission instead.
			*
			* Firefox with html5notifications plugin supports this method
			* for requesting permissions.
			*/
			win.webkitNotifications.requestPermission(callbackFunction);
		} else if (win.Notification && win.Notification.requestPermission) {
			win.Notification.requestPermission(callbackFunction);
		}
	}
	function permissionLevel() {
		var permission;
		if (!isSupported) { return; }
		if (win.Notification && win.Notification.permissionLevel) {
			//Safari 6
			permission = win.Notification.permissionLevel();
		} else if (win.webkitNotifications && win.webkitNotifications.checkPermission) {
			//Chrome & Firefox with html5-notifications plugin installed
			permission = PERMISSION[win.webkitNotifications.checkPermission()];
		} else if (win.Notification && win.Notification.permission) {
			// Firefox 23+
			permission = win.Notification.permission;
		} else if (navigator.mozNotification) {
			//Firefox Mobile
			permission = PERMISSION_GRANTED;
		} else if (win.external && (win.external.msIsSiteMode() !== undefined)) { /* keep last */
			//IE9+
			permission = win.external.msIsSiteMode() ? PERMISSION_GRANTED : PERMISSION_DEFAULT;
		}
		return permission;
	}
	/**
	*
	*/
	function config(params) {
		if (params && isObject(params)) {
			mixin(settings, params);
		}
		return settings;
	}
	function createNotification(title, options) {
		var notification,
		notificationWrapper;
		/*
		Return undefined if notifications are not supported.
		Return undefined if no permissions for displaying notifications.
		Title and icons are required. Return undefined if not set.
		*/
		if (isSupported && isString(title) && (options && (isString(options.icon) || isObject(options.icon))) && (permissionLevel() === PERMISSION_GRANTED)) {
			notification = getNotification(title, options);
		}
		notificationWrapper = getWrapper(notification);
		//Auto-close notification
		if (settings.autoClose && notification && !notification.ieVerification && notification.addEventListener) {
			notification.addEventListener("show", function () {
				var notification = notificationWrapper;
				win.setTimeout(function () {
					notification.close();
				}, settings.autoClose);
			});
		}
		return notificationWrapper;
	}
	win.notify = {
		PERMISSION_DEFAULT: PERMISSION_DEFAULT,
		PERMISSION_GRANTED: PERMISSION_GRANTED,
		PERMISSION_DENIED: PERMISSION_DENIED,
		isSupported: isSupported,
		config: config,
		createNotification: createNotification,
		permissionLevel: permissionLevel,
		requestPermission: requestPermission
	};
	if (isFunction(Object.seal)) {
		Object.seal(win.notify);
	}
}(window));
;var Base_Notify = {
	interval: 0,
	disabled: 0,
	disabled_message: 'Notifications disabled!',
	working: 0,
	
	init: function(refresh_interval, disabled_message) {
		this.set_interval(refresh_interval);
		this.disabled_message = disabled_message;
		this.refresh();
	},
	
	set_interval: function (t) {
		if (!this.is_active()) return;
		
		clearInterval(this.interval);
				
		this.interval = setInterval(function () {Base_Notify.refresh();}, t);
	},
	
	refresh: function () {
		if (!this.is_active()) return;

		if(this.working) return;
		this.working = 1;

		jq.getJSON('modules/Base/Notify/refresh.php', function(json){
			this.working = 0;

			if (typeof json === 'undefined' || jq.isEmptyObject(json)) return;
			if (typeof json.disable !== 'undefined') {
				Base_Notify.disable();
				return;	
			}

			if (typeof json.messages === 'undefined') return;
			
			jq.each(json.messages, function(i, m) {
				setTimeout(function(){
					if (typeof m.timeout !== 'undefined') notify.config({pageVisibility: false, autoClose: m.timeout});
					Base_Notify.notify(m.title, m.opts);			
				}, i*500);
			});
		});		
	},
	
	notify: function (title, opts) {
		if (!this.is_active(true)) return;
		
		if (notify.permissionLevel() === notify.PERMISSION_DEFAULT) {
			notify.requestPermission(function (permission) {
				if (permission === notify.PERMISSION_GRANTED) {
					var n = notify.createNotification(title, opts);
				}
			});
		}
		else if (notify.permissionLevel() === notify.PERMISSION_GRANTED) {
			var n = notify.createNotification(title, opts);
		}
	},
	
	is_active: function (alert) {
		if (this.disabled) return false;
		
		if (!this.is_supported(alert)) {
			this.disable();
			return false;
		}
		
		return true;
	},
	
	is_supported: function (alert) {
		supported = notify.isSupported && (notify.permissionLevel() !== notify.PERMISSION_DENIED);
		
		if (!supported && alert) alert(this.disabled_message);
		
		return supported;
	},
	
	disable: function () {
		clearInterval(this.interval);
		this.interval = 0;
		this.disabled = 1;
	}
};

;sort_applet_sort_fn = function(a,b) {
    return jq(a).attr('searchkey')>jq(b).attr('searchkey');
}

sort_applet_selection_panel = function () {
    var a = jq('#dashboard_applets_new');
    a.children().sort(sort_applet_sort_fn).appendTo(a);
}

dashboard_activate = function(tabs, default_dash,allowed_management) {
  if(!jq('#dashboard').length) return;
  sort_applet_selection_panel();
  var new_applets = jq('#dashboard_applets_new');

    if (allowed_management) {
        jq(tabs).each(function(i,tab) {
            var cols = jq("#dashboard_applets_"+tab+"_0, #dashboard_applets_"+tab+"_1, #dashboard_applets_"+tab+"_2, #dashboard_applets_new");
            for(var id=0; id<3; id++) {
                jq("#dashboard_applets_"+tab+"_"+id).attr('tab',tab).attr('col_id',id).sortable({handle:'.handle',connectWith:cols,update:function(ev,ui){
                    var t = jq(this);

                    t.children().each(function(ii,ee) {
                        ee = jq(ee);
                        if(ee.attr('id').indexOf('ab_item_new_')!=-1) {
                            var appletCopy = ee.get(0).cloneNode(true);
                            new_applets.append(appletCopy);
                            appletCopy.style.opacity = 1;
                            appletCopy.style.top = 0;
                            appletCopy.style.left = 0;
                            sort_applet_selection_panel();

                            ee.attr('id','copy_'+ee.attr('id'));
                            ee.find('a').each(function(jj,link){
                                if(link.id.substr(0,24)=="dashboard_remove_applet_")
                                    link.setAttribute('id','copy_'+link.id);
                            });
                            ee.find('div').each(function(jj,div){
                                if(div.id.substr(0,25)=="dashboard_applet_content_")
                                    div.setAttribute('id','copy_'+div.id);
                            });
                        }
                    });

                    jq.post("modules/Base/Dashboard/update.php",{
                            data:t.sortable('serialize',{expression:'(ab_item)_(.+)'}),
                            default_dash: default_dash,
                            tab: tab,
                            col:t.attr('col_id')
                        },function(t) {
                            eval(t);
                        }
                    );
                }});
            }
        });

        if (new_applets.length>0)
            new_applets.sortable({handle:'.handle',connectWith:jq('#dashboard > .ui-sortable'),update:function(ev,ui){
                var t = jq(this);
                // remove instanced applets from the list
                t.children().each(function(ii,ee) {
                    ee = jq(ee);
                    if(ee.attr('id').indexOf('ab_item_new_')==-1) {
                        ee.hide();
                    }
                });
                jq.post("modules/Base/Dashboard/update.php",{
                        data: t.sortable('serialize',{expression:'(ab_item)_(.+)'}),
                        default_dash: default_dash,
                        tab: '',
                        col: 'new'
                    }, function(t) {
                        eval(t);
                    }
                );
            }});
    }

  //applet toggle buttons
  jq('#dashboard .applet').each(function(i,a) {
        var aa = jq(a);
        aa.find('a.toggle').click(function(b) {
            aa.find('.content').toggle('blind');
        });
  });
}

remove_applet = function(id, default_dash) {
    var elem = jq("#ab_item_"+id);
	if (elem.length)
		elem.hide('fade');
    jq.post("modules/Base/Dashboard/remove_applet.php",{
        id: id,
        default_dash: default_dash
    },function(t) {
        eval(t);
    });
}

get_new_dashboard_tab_name = function(query, error, id) {
	var name = prompt(query, '');
	if (name == null) return false;
	if (name == '') {
		alert(error);
		return false;
	}
	jq('#dashboard_tab_name').val(name);
	jq('#dashboard_tab_id').val(id);
	return true;
}

dashboard_prepare_filter_box = function(focus, message) {
	if (focus && jq("#dashboard_applets_filter").val() == message) {
		jq("#dashboard_applets_filter").css('color',"");
		jq("#dashboard_applets_filter").val("");
	} 
	if (!focus && jq("#dashboard_applets_filter").val() == "") {
		jq("#dashboard_applets_filter").css('color',"#555");
		jq("#dashboard_applets_filter").val(message);
	}
}

dashboard_filter_applets = function() {
	var str = jq("#dashboard_applets_filter").val().toLowerCase();
	var nodes = jq("#dashboard_applets_new").children();
    nodes.each(function(i,nodeObj) {
        var node = jq(nodeObj);
        if(node.attr('searchkey').indexOf(str)!=-1) node.show(); else node.hide();
    });
}

;watchdog_applet_mark_as_read = function(key) {
	var rows = document.getElementsByName("watchdog_table_row_"+key);
	for (i=0; i<rows.length; i++)
		rows[i].style.display="none";
	jq.ajax({
		type: 'POST',
		url: 'modules/Utils/Watchdog/mark_as_read.php', 
		data:{
			key: key,
			cid: Epesi.client_id
		}
	});
}
;/**
               _ _____           _          _     _      
              | |  __ \         (_)        | |   | |     
      ___ ___ | | |__) |___  ___ _ ______ _| |__ | | ___ 
     / __/ _ \| |  _  // _ \/ __| |_  / _` | '_ \| |/ _ \
    | (_| (_) | | | \ \  __/\__ \ |/ / (_| | |_) | |  __/
     \___\___/|_|_|  \_\___||___/_/___\__,_|_.__/|_|\___|
	 
	v 1.5 - a jQuery plug-in by Alvaro Prieto Lauroba
	
	Licences: MIT & GPL
	Feel free to use or modify this plugin as far as my full name is kept	
	
	If you are going to use this plug-in in production environments it is 
	strongly recommended to use its minified version: colResizable.min.js

*/

(function(jq){ 	
	
	var d = jq(document); 		//window object
	var h = jq("head");			//head object
	var drag = null;			//reference to the current grip that is being dragged
	var tables = {};			//array of the already processed tables (table.id as key)
	var	count = 0;				//internal count to create unique IDs when needed.	
	
	//common strings for packing
	var ID = "cols_width_id";	
	var PX = "px";
	var SIGNATURE ="JColResizer";
    var FLEX = "JCLRFlex";
	
	//short-cuts
	var I = parseInt;
	var M = Math;
	var ie = navigator.userAgent.indexOf('Trident/4.0')>0;
	var S;
	//modified by Georgi Hristov
	//try{S = sessionStorage;}catch(e){}	//Firefox crashes when executed as local file system
	try{S = localStorage;}catch(e){}	//Firefox crashes when executed as local file system
	
	//append required CSS rules  
	h.append("<style type='text/css'>  .JColResizer{table-layout:fixed;} .JColResizer td, .JColResizer th{overflow:hidden;}  .JCLRgrips{ height:0px; position:relative;} .JCLRgrip{margin-left:-5px; position:absolute; z-index:5; } .JCLRgrip .JColResizer{position:absolute;background-color:red;filter:alpha(opacity=1);opacity:0;width:10px;height:100%;cursor: e-resize;top:0px} .JCLRLastGrip{position:absolute; width:1px; } .JCLRgripDrag{ border-left:1px dotted black;	} .JCLRFlex{width:auto!important;}</style>");

	
	/**
	 * Function to allow column resizing for table objects. It is the starting point to apply the plugin.
	 * @param {DOM node} tb - reference to the DOM table object to be enhanced
	 * @param {Object} options	- some customization values
	 */
	var init = function( tb, options){	
		var t = jq(tb);										//the table object is wrapped
		t.opt = options;
		if(t.opt.disable) return destroy(t);				//the user is asking to destroy a previously colResized table
		var	id = t.id = t.attr(ID) || SIGNATURE+count++;	//its id is obtained, if null new one is generated		
		t.p = t.opt.postbackSafe; 							//short-cut to detect postback safe 		
		if(!t.is("table") || tables[id] && !t.opt.partialRefresh) return; 		//if the object is not a table or if it was already processed then it is ignored.
		t.addClass(SIGNATURE).attr(ID, id).before('<div class="JCLRgrips"/>');	//the grips container object is added. Signature class forces table rendering in fixed-layout mode to prevent column's min-width
		t.g = []; t.c = []; t.w = t.width(); t.gc = t.prev(); t.f=t.opt.fixed;	//t.c and t.g are arrays of columns and grips respectively				
		if(options.marginLeft) t.gc.css("marginLeft", options.marginLeft);  	//if the table contains margins, it must be specified
		if(options.marginRight) t.gc.css("marginRight", options.marginRight);  	//since there is no (direct) way to obtain margin values in its original units (%, em, ...)
		t.cs = I(ie? tb.cellSpacing || tb.currentStyle.borderSpacing :t.css('border-spacing'))||2;	//table cellspacing (not even jQuery is fully cross-browser)
		t.b  = I(ie? tb.border || tb.currentStyle.borderLeftWidth :t.css('border-left-width'))||1;	//outer border width (again cross-browser issues)
		// if(!(tb.style.width || tb.width)) t.width(t.width()); //I am not an IE fan at all, but it is a pity that only IE has the currentStyle attribute working as expected. For this reason I can not check easily if the table has an explicit width or if it is rendered as "auto"
		tables[id] = t; 	//the table object is stored using its id as key	
		createGrips(t);		//grips are created
	
	};


	/**
	 * This function allows to remove any enhancements performed by this plugin on a previously processed table.
	 * @param {jQuery ref} t - table object
	 */
	var destroy = function(t){
		var id=t.attr(ID), t=tables[id];		//its table object is found
		if(!t||!t.is("table")) return;			//if none, then it wasn't processed	 
		t.removeClass(SIGNATURE+" "+FLEX).gc.remove();	//class and grips are removed
		delete tables[id];						//clean up data
	};


	/**
	 * Function to create all the grips associated with the table given by parameters 
	 * @param {jQuery ref} t - table object
	 */
	var createGrips = function(t){	
	
		var th = t.find(">thead>tr>th,>thead>tr>td");	//if table headers are specified in its semantically correct tag, are obtained
		if(!th.length) th = t.find(">tbody>tr:first>th,>tr:first>th,>tbody>tr:first>td, >tr:first>td");	 //but headers can also be included in different ways
		th = th.filter(":visible");					//filter invisible columns
		if (t.opt.skipColumnClass) th = th.filter(':not('+t.opt.skipColumnClass+')');	//ADDED BY Georgi Hristov - filter skipped columns
		t.cg = t.find("col"); 						//a table can also contain a colgroup with col elements		
		t.ln = th.length;							//table length is stored	
		if(t.p && S && S[t.id])memento(t,th);		//if 'postbackSafe' is enabled and there is data for the current table, its coloumn layout is restored
		th.each(function(i){						//iterate through the table column headers			
			var c = jq(this); 						//jquery wrap for the current column			
			var g = jq(t.gc.append('<div class="JCLRgrip"></div>')[0].lastChild); //add the visual node to be used as grip
            g.append(t.opt.gripInnerHtml).append('<div class="'+SIGNATURE+'"></div>');
            if(i == t.ln-1){
                g.addClass("JCLRLastGrip"); 
                if(t.f) g.html("");
            }
            g.bind('touchstart mousedown', onGripMouseDown); //bind the mousedown event to start dragging 

			g.t = t; g.i = i; g.c = c;	c.w =c.width();		//some values are stored in the grip's node data
			t.g.push(g); t.c.push(c);						//the current grip and column are added to its table object
			c.width(c.w).removeAttr("width");				//the width of the column is converted into pixel-based measurements
			g.data(SIGNATURE, {i:i, t:t.attr(ID), last: i == t.ln-1});	 //grip index and its table name are stored in the HTML 												
		}); 	
		t.cg.removeAttr("width");	//remove the width attribute from elements in the colgroup 
		syncGrips(t); 				//the grips are positioned according to the current table layout			
		//there is a small problem, some cells in the table could contain dimension values interfering with the 
		//width value set by this plugin. Those values are removed
		t.find('td, th').not(th).not('table th, table td').each(function(){  
			jq(this).removeAttr('width');	//the width attribute is removed from all table cells which are not nested in other tables and dont belong to the header
		});		
        if(!t.f){
            t.removeAttr('width').addClass(FLEX); //if not fixed, let the table grow as needed
        }

		
	};
	
    
	/**
	 * Function to allow the persistence of columns dimensions after a browser postback. It is based in
	 * the HTML5 sessionStorage object, which can be emulated for older browsers using sessionstorage.js
	 * @param {jQuery ref} t - table object
	 * @param {jQuery ref} th - reference to the first row elements (only set in deserialization)
	 */
	var memento = function(t, th){ 
		var w,m=0,i=0,aux =[],tw;
		if(th){										//in deserialization mode (after a postback)
			t.cg.removeAttr("width");
			if(t.opt.flush){ S[t.id] =""; return;} 	//if flush is activated, stored data is removed
			w = S[t.id].split(";");					//column widths is obtained
			tw = w[t.ln+1];
			if(!t.f && tw)	t.width(tw);			//it not fixed and table width data available its size is restored
			for(;i<t.ln;i++){						//for each column
				aux.push(100*w[i]/w[t.ln]+"%"); 	//width is stored in an array since it will be required again a couple of lines ahead
				th.eq(i).css("width", aux[i] ); 	//each column width in % is restored
			}			
			for(i=0;i<t.ln;i++)
				t.cg.eq(i).css("width", aux[i]);	//this code is required in order to create an inline CSS rule with higher precedence than an existing CSS class in the "col" elements
		}else{							//in serialization mode (after resizing a column)
			S[t.id] ="";				//clean up previous data
			for(;i < t.c.length; i++){	//iterate through columns
				w = t.c[i].width();		//width is obtained
				S[t.id] += w+";";		//width is appended to the sessionStorage object using ID as key
				m+=w;					//carriage is updated to obtain the full size used by columns
			}
			S[t.id]+=m;							//the last item of the serialized string is the table's active area (width), 
												//to be able to obtain % width value of each columns while deserializing
			if(!t.f) S[t.id] += ";"+t.width(); 	//if not fixed, table width is stored
		}	
	};
	
	
	/**
	 * Function that places each grip in the correct position according to the current table layout	 
	 * @param {jQuery ref} t - table object
	 */
	var syncGrips = function (t){	
		t.gc.width(t.w);			//the grip's container width is updated				
		for(var i=0; i<t.ln; i++){	//for each column
			var c = t.c[i]; 			
			t.g[i].css({			//height and position of the grip is updated according to the table layout
				left: c.offset().left - t.offset().left + c.outerWidth(false) + t.cs / 2 + PX,
				height: t.opt.headerOnly? t.c[0].outerHeight(false) : t.outerHeight(false)				
			});			
		} 	
	};
	
	
	
	/**
	* This function updates column's width according to the horizontal position increment of the grip being
	* dragged. The function can be called while dragging if liveDragging is enabled and also from the onGripDragOver
	* event handler to synchronize grip's position with their related columns.
	* @param {jQuery ref} t - table object
	* @param {number} i - index of the grip being dragged
	* @param {bool} isOver - to identify when the function is being called from the onGripDragOver event	
	*/
	var syncCols = function(t,i,isOver){
		var inc = drag.x-drag.l, c = t.c[i], c2 = t.c[i+1]; 			
		var w = c.w + inc;	var w2= c2.w- inc;	//their new width is obtained					
		c.width( w + PX);			
		t.cg.eq(i).width( w + PX); 
        if(t.f){ //if fixed mode
            c2.width(w2 + PX);
            t.cg.eq(i+1).width( w2 + PX);
        }
		if(isOver){
            c.w=w; 
            c2.w= t.f ? w2 : c2.w;
        }
	};

	
	/**
	* This function updates all columns width according to its real width. It must be taken into account that the 
	* sum of all columns can exceed the table width in some cases (if fixed is set to false and table has some kind 
	* of max-width).
	* @param {jQuery ref} t - table object	
	*/
	var applyBounds = function(t){
        var w = jq.map(t.c, function(c){			//obtain real widths
            return c.width();
        });
        t.width(t.width()).removeClass(FLEX);	//prevent table width changes
        jq.each(t.c, function(i,c){
            c.width(w[i]).w = w[i];				//set column widths applying bounds (table's max-width)
        });
		t.addClass(FLEX);						//allow table width changes
	};
	
	
	/**
	 * Event handler used while dragging a grip. It checks if the next grip's position is valid and updates it. 
	 * @param {event} e - mousemove event binded to the window object
	 */
	var onGripDrag = function(e){	
		if(!drag) return; 
        var t = drag.t;		//table object reference 
        var oe = e.originalEvent.touches;
        var ox = oe ? oe[0].pageX : e.pageX;    //original position (touch or mouse)
        var x =  ox - drag.ox + drag.l;	        //next position according to horizontal mouse position increment
		var mw = t.opt.minWidth, i = drag.i ;	//cell's min width
		var l = t.cs*1.5 + mw + t.b;
        var last = i == t.ln-1;                 			//check if it is the last column's grip (usually hidden)
        var min = i? t.g[i-1].position().left+t.cs+mw: l;	//min position according to the contiguous cells
		var max = t.f ? 	//fixed mode?
			i == t.ln-1? 
				t.w-l: 
				t.g[i+1].position().left-t.cs-mw:
			Infinity; 								//max position according to the contiguous cells 
		x = M.max(min, M.min(max, x));				//apply bounding		
		drag.x = x;	 drag.css("left",  x + PX); 	//apply position increment	
        if(last){									//if it is the last grip
            var c = t.c[drag.i];					//width of the last column is obtained
			drag.w = c.w + x- drag.l;         
        }              
		if(t.opt.liveDrag){ 			//if liveDrag is enabled
			if(last){
			    c.width(drag.w);
                t.w = t.width();
			}else{
				syncCols(t,i); 			//columns are synchronized
			}
			syncGrips(t);
			var cb = t.opt.onDrag;							//check if there is an onDrag callback
			if (cb) { e.currentTarget = t[0]; cb(e); }		//if any, it is fired			
		}
		return false; 	//prevent text selection while dragging				
	};
	

	/**
	 * Event handler fired when the dragging is over, updating table layout
	 */
	var onGripDragOver = function(e){	
		
		d.unbind('touchend.'+SIGNATURE+' mouseup.'+SIGNATURE).unbind('touchmove.'+SIGNATURE+' mousemove.'+SIGNATURE);
		jq("head :last-child").remove(); 				//remove the dragging cursor style	
		if(!drag) return;
		drag.removeClass(drag.t.opt.draggingClass);		//remove the grip's dragging css-class
		var t = drag.t;
		var cb = t.opt.onResize; 	    //get some values	
        var i = drag.i;                 //column index
        var last = i == t.ln-1;         //check if it is the last column's grip (usually hidden)
        var c = t.g[i].c;               //the column being dragged
        if(last){
            c.width(drag.w);
            c.w = drag.w;
        }else{
            syncCols(t, i, true);	//the columns are updated
        }
        if(!t.f) applyBounds(t);	//if not fixed mode, then apply bounds to obtain real width values
        syncGrips(t);				//the grips are updated
        if (cb) { e.currentTarget = t[0]; cb(e); }	//if there is a callback function, it is fired
		if(t.p && S) memento(t); 						//if postbackSafe is enabled and there is sessionStorage support, the new layout is serialized and stored
		drag = null;									//since the grip's dragging is over									
	};	
	
	
	/**
	 * Event handler fired when the grip's dragging is about to start. Its main goal is to set up events 
	 * and store some values used while dragging.
     * @param {event} e - grip's mousedown event
	 */
	var onGripMouseDown = function(e){
		var o = jq(this).data(SIGNATURE);			//retrieve grip's data
		var t = tables[o.t],  g = t.g[o.i];			//shortcuts for the table and grip objects
        var oe = e.originalEvent.touches;           //touch or mouse event?
        g.ox = oe? oe[0].pageX: e.pageX;            //the initial position is kept
		g.l = g.position().left;
		d.bind('touchmove.'+SIGNATURE+' mousemove.'+SIGNATURE, onGripDrag ).bind('touchend.'+SIGNATURE+' mouseup.'+SIGNATURE, onGripDragOver);	//mousemove and mouseup events are bound
		h.append("<style type='text/css'>*{cursor:"+ t.opt.dragCursor +"!important}</style>"); 	//change the mouse cursor
		g.addClass(t.opt.draggingClass); 	//add the dragging class (to allow some visual feedback)				
		drag = g;							//the current grip is stored as the current dragging object
		if(t.c[o.i].l) for(var i=0,c; i<t.ln; i++){ c=t.c[i]; c.l = false; c.w= c.width(); } 	//if the colum is locked (after browser resize), then c.w must be updated		
		return false; 	//prevent text selection
	};
    
    
	/**
	 * Event handler fired when the browser is resized. The main purpose of this function is to update
	 * table layout according to the browser's size synchronizing related grips 
	 */
	var onResize = function(){
		for(t in tables){		
			var t = tables[t], i, mw=0;	
			t.removeClass(SIGNATURE);						//firefox doesn't like layout-fixed in some cases
			t.w = t.width();							//its new value is kept the active cells area is obtained
			for(i=0; i<t.ln; i++) mw+= t.c[i].w;		
			//cell rendering is not as trivial as it might seem, and it is slightly different for
			//each browser. In the beginning i had a big switch for each browser, but since the code
			//was extremely ugly now I use a different approach with several re-flows. This works 
			//pretty well but it's a bit slower. For now, lets keep things simple...   
			for(i=0; i<t.ln; i++) t.c[i].css("width", M.round(1000*t.c[i].w/mw)/10 + "%").l=true; 
			//c.l locks the column, telling us that its c.w is outdated									
			syncGrips(t.addClass(SIGNATURE));
		} 
		
	};	


	//bind resize event, to update grips position 
	jq(window).bind('resize.'+SIGNATURE, onResize); 


	/**
	 * The plugin is added to the jQuery library
	 * @param {Object} options -  an object that holds some basic customization values 
	 */
    jq.fn.extend({  
        colResizable: function(options) {           
            var defaults = {
			
				//attributes:
                draggingClass: 'JCLRgripDrag',	//css-class used when a grip is being dragged (for visual feedback purposes)
				gripInnerHtml: '',				//if it is required to use a custom grip it can be done using some custom HTML				
				liveDrag: false,				//enables table-layout updating while dragging	
                fixed: true,                    //table width does not change if columns are resized
				minWidth: 15, 					//minimum width value in pixels allowed for a column 
				headerOnly: false,				//specifies that the size of the the column resizing anchors will be bounded to the size of the first row 
				hoverCursor: "e-resize",  		//cursor to be used on grip hover
				dragCursor: "e-resize",  		//cursor to be used while dragging
				postbackSafe: false, 			//when it is enabled, table layout can persist after postback or page refresh. It requires browsers with sessionStorage support (it can be emulated with sessionStorage.js). 
				flush: false, 					//when postbakSafe is enabled, and it is required to prevent layout restoration after postback, 'flush' will remove its associated layout data 
				marginLeft: null,				//in case the table contains any margins, colResizable needs to know the values used, e.g. "10%", "15em", "5px" ...
				marginRight: null, 				//in case the table contains any margins, colResizable needs to know the values used, e.g. "10%", "15em", "5px" ...
				disable: false,					//disables all the enhancements performed in a previously colResized table	
				partialRefresh: false,			//can be used in combination with postbackSafe when the table is inside of an updatePanel
				skipColumnClass: false,			//ADDED BY Georgi Hristov - columns to skip
				
				//events:
				onDrag: null, 					//callback function to be fired during the column resizing process if liveDrag is enabled
				onResize: null					//callback function fired when the dragging process is over
            }			
			var options =  jq.extend(defaults, options);			
            return this.each(function() {				
             	init( this, options);             
            });
        }
    });
})(jQuery);


;function quick_jump_letters(id) {
   Effect.toggle('quick_jump_letters_' + id, 'appear', {duration:0.3});
}

;jump_to_record_id = function (tab) {
	if ($("jump_to_record_input").style.display=="")
		$("jump_to_record_input").style.display = "none";
	else
		$("jump_to_record_input").style.display = "";
	focus_by_id("jump_to_record_input");
}

;Utils_LeightboxPrompt = {
	init : function(group, active_option_key) {
		if (active_option_key)
			Utils_LeightboxPrompt.show_form(group, active_option_key);
		else
			Utils_LeightboxPrompt.show_buttons(group);
	},
	activate : function(group, params) {
		leightbox_activate(group + '_prompt_leightbox');
		Utils_LeightboxPrompt.set_params(group, params);
	},
	set_params : function(group, params) {
		if (!params) return;

		params = jq.type(params)==='string'? jq.deparam(params): params;

		jq.each(params, function(key, value) {
			jq('[name="' + group + '_' + key + '"]').val(value);
		});
	},
	deactivate : function(group, reset_view) {
		leightbox_deactivate(group + '_prompt_leightbox');

		if (reset_view) {
			Utils_LeightboxPrompt.show_buttons(group);
		}
	},
	show_buttons : function(group) {
		jq('.' + group + '_form_section').hide();
		jq('#' + group + '_buttons_section').show();
	},
	show_form : function(group, option_key) {
		jq('#' + group + '_' + option_key + '_form_section').show();
		jq('#' + group + '_buttons_section').hide();
	}
}
;(function(deparam){
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        try {
            var jquery = require('jquery');
        } catch (e) {
        }
        module.exports = deparam(jquery);
    } else if (typeof define === 'function' && define.amd){
        define(['jquery'], function(jquery){
            return deparam(jquery);
        });
    } else {
        var global;
        try {
          global = (false || eval)('this'); // best cross-browser way to determine global for < ES5
        } catch (e) {
          global = window; // fails only if browser (https://developer.mozilla.org/en-US/docs/Web/Security/CSP/CSP_policy_directives)
        }
        global.deparam = deparam(global.jQuery); // assume jQuery is in global namespace
    }
})(function ($) {
    var deparam = function( params, coerce ) {
        var obj = {},
        coerce_types = { 'true': !0, 'false': !1, 'null': null };

        // Iterate over all name=value pairs.
        params.replace(/\+/g, ' ').split('&').forEach(function(v){
            var param = v.split( '=' ),
            key = decodeURIComponent( param[0] ),
            val,
            cur = obj,
            i = 0,

            // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
            // into its component parts.
            keys = key.split( '][' ),
            keys_last = keys.length - 1;

            // If the first keys part contains [ and the last ends with ], then []
            // are correctly balanced.
            if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
                // Remove the trailing ] from the last keys part.
                keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );

                // Split first keys part into two parts on the [ and add them back onto
                // the beginning of the keys array.
                keys = keys.shift().split('[').concat( keys );

                keys_last = keys.length - 1;
            } else {
                // Basic 'foo' style key.
                keys_last = 0;
            }

            // Are we dealing with a name=value pair, or just a name?
            if ( param.length === 2 ) {
                val = decodeURIComponent( param[1] );

                // Coerce values.
                if ( coerce ) {
                    val = val && !isNaN(val) && ((+val + '') === val) ? +val        // number
                    : val === 'undefined'                       ? undefined         // undefined
                    : coerce_types[val] !== undefined           ? coerce_types[val] // true, false, null
                    : val;                                                          // string
                }

                if ( keys_last ) {
                    // Complex key, build deep object structure based on a few rules:
                    // * The 'cur' pointer starts at the object top-level.
                    // * [] = array push (n is set to array length), [n] = array if n is
                    //   numeric, otherwise object.
                    // * If at the last keys part, set the value.
                    // * For each keys part, if the current level is undefined create an
                    //   object or array based on the type of the next keys part.
                    // * Move the 'cur' pointer to the next level.
                    // * Rinse & repeat.
                    for ( ; i <= keys_last; i++ ) {
                        key = keys[i] === '' ? cur.length : keys[i];
                        cur = cur[key] = i < keys_last
                        ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
                        : val;
                    }

                } else {
                    // Simple key, even simpler rules, since only scalars and shallow
                    // arrays are allowed.

                    if ( Object.prototype.toString.call( obj[key] ) === '[object Array]' ) {
                        // val is already an array, so push on the next value.
                        obj[key].push( val );

                    } else if ( {}.hasOwnProperty.call(obj, key) ) {
                        // val isn't an array, but since a second value has been specified,
                        // convert val into an array.
                        obj[key] = [ obj[key], val ];

                    } else {
                        // val is a scalar.
                        obj[key] = val;
                    }
                }

            } else if ( key ) {
                // No value was defined, so set something meaningful.
                obj[key] = coerce
                ? undefined
                : '';
            }
        });

        return obj;
    };
    if ($) {
      $.prototype.deparam = $.deparam = deparam;
    }
    return deparam;
});

;/*
Created By: Chris Campbell
Website: http://particletree.com
Date: 2/1/2006

Adapted By: Simon de Haan
Website: http://blog.eight.nl
Date: 21/2/2006

Adapted for epesi by: Paul Bukowski
Date: 01/06/2007

Inspired by the lightbox implementation found at http://www.huddletogether.com/projects/lightbox/
And the lightbox gone wild by ParticleTree at http://particletree.com/features/lightbox-gone-wild/

*/

/*-------------------------------GLOBAL VARIABLES------------------------------------*/

var detect = navigator.userAgent.toLowerCase();
var OS,browser,version,total,thestring;

/*-----------------------------------------------------------------------------------------------*/

//Browser detect script origionally created by Peter Paul Koch at http://www.quirksmode.org/

function getBrowserInfo() {
    if (checkIt('konqueror')) {
        browser = "Konqueror";
        OS = "Linux";
    }
    else if (checkIt('safari')) browser     = "Safari"
    else if (checkIt('omniweb')) browser    = "OmniWeb"
    else if (checkIt('opera')) browser      = "Opera"
    else if (checkIt('webtv')) browser      = "WebTV";
    else if (checkIt('icab')) browser       = "iCab"
    else if (checkIt('msie')) browser       = "Internet Explorer"
    else if (!checkIt('compatible')) {
        browser = "Netscape Navigator"
        version = detect.charAt(8);
    }
    else browser = "An unknown browser";

    if (!version) version = detect.charAt(place + thestring.length);

    if (!OS) {
        if (checkIt('linux')) OS        = "Linux";
        else if (checkIt('x11')) OS     = "Unix";
        else if (checkIt('mac')) OS     = "Mac"
        else if (checkIt('win')) OS     = "Windows"
        else OS                                 = "an unknown operating system";
    }
}

function checkIt(string) {
    place = detect.indexOf(string) + 1;
    thestring = string;
    return place;
}

/*-----------------------------------------------------------------------------------------------*/

var leightbox = Class.create();

leightbox.prototype = {

    yPos : 0,

    initialize: function(ctrl) {
        this.content = ctrl.getAttribute("rel");
	var exec = this.activate.bindAsEventListener(this);
        Event.observe(ctrl, 'click', exec, false);
	jq(ctrl).on('touchstart',function(){jq(this).attr('last_touch_start',(new Date()).getTime());}).on('touchend',function(){ var a = (new Date()).getTime()-jq(this).attr('last_touch_start'); if(a>200 && a<1000) exec() });

        ctrl.onclick = function(){return false;};
    },

    // Turn everything on - mainly the IE fixes
    activate: function(){
		leightbox_is_active = true;
        if (browser == 'Internet Explorer'){
            this.getScroll();
            this.prepareIE('100%', 'hidden');
            this.setScroll(0,0);
            this.hideSelects('hidden');
        }
        this.displayLeightbox("block");
    },

    // Ie requires height to 100% and overflow hidden or else you can scroll down past the leightbox
    prepareIE: function(height, overflow){
        bod = document.getElementsByTagName('body')[0];
        bod.style.height = height;
        bod.style.overflow = overflow;

        htm = document.getElementsByTagName('html')[0];
        htm.style.height = height;
        htm.style.overflow = overflow;
    },

    // In IE, select elements hover on top of the leightbox
    hideSelects: function(visibility){
        selects = document.getElementsByTagName('select');
        for(i = 0; i < selects.length; i++) {
            selects[i].style.visibility = visibility;
        }
    },

    // Taken from leightbox implementation found at http://www.huddletogether.com/projects/lightbox/
    getScroll: function(){
        if (self.pageYOffset) {
            this.yPos = self.pageYOffset;
        } else if (document.documentElement && document.documentElement.scrollTop){
            this.yPos = document.documentElement.scrollTop;
        } else if (document.body) {
            this.yPos = document.body.scrollTop;
        }
    },

    setScroll: function(x, y){
        window.scrollTo(x, y);
    },

    displayLeightbox: function(display){
        var c = $(this.content);
        var co = $('leightbox_overlay');
        var ccont = $('leightbox_container');
        if(display == 'none') {
            var tag = $(this.content+'__tag');
            if(tag) {
            tag.parentNode.insertBefore(c,tag);
            tag.parentNode.removeChild(tag);
            } else {
                c.id = this.content+"__bak";
            var c2 = $(this.content);
            if(c2) c2.parentNode.removeChild(c2);
                c.id = this.content;
            }
        } else {
            var tag = document.createElement('div');
            tag.id = this.content+'__tag';
            c.parentNode.insertBefore(tag,c);
            ccont.appendChild(c);
            if(navigator.appName.indexOf('Explorer') != -1 ) {
            co.style.position="absolute";
            co.style.height = (document.documentElement.clientHeight < document.body.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight) + 'px';
            c.style.position="absolute";
            c.style.top = (document.documentElement.scrollTop + document.documentElement.clientHeight/4) + 'px';
            c.style.left = (document.documentElement.scrollLeft + document.documentElement.clientWidth/6) + 'px';
            c.style.height = (document.documentElement.clientHeight/2) + 'px';
            c.style.width = (document.documentElement.clientWidth/1.5) + 'px';
            }
        }
        co.style.display = display;
        c.style.display = display;
        if(display != 'none') this.actions();
    },

    // Search through new links within the lightbox, and attach click event
    actions: function(){
        lbActions = document.getElementsByClassName('lbAction');

        for(i = 0; i < lbActions.length; i++) {
            Event.observe(lbActions[i], 'click', this[lbActions[i].getAttribute("rel")].bindAsEventListener(this), false);
            lbActions[i].onclick = function(){return false;};
        }

    },

    // Example of creating your own functionality once lightbox is initiated
    deactivate: function(){
		leightbox_is_active = false;
        if (browser == "Internet Explorer"){
            this.setScroll(0,this.yPos);
            this.prepareIE("auto", "visible");
            this.hideSelects("visible");
        }

        this.displayLeightbox("none");
    }
}

/*-----------------------------------------------------------------------------------------------*/

var leightboxes = Array();
var leightbox_to_activate = '';

// Add in markup necessary to make this work. Basically two divs:
// Overlay holds the shadow
// Lightbox is the centered square that the content is put into.
function addLeightboxMarkup() {
    bod                 = document.getElementsByTagName('body')[0];

    leightbox_overlay           = document.createElement('div');
    leightbox_overlay.style.display = 'none';
    leightbox_overlay.id            = 'leightbox_overlay';
    leightbox_overlay.className     = 'leightbox_overlay';
    bod.appendChild(leightbox_overlay);

    leightbox_container             = document.createElement('div');
    leightbox_container.id          = 'leightbox_container';
    bod.appendChild(leightbox_container);
}

leightbox_is_active = false;

function leightbox_deactivate(name) {
for(i=0;i<leightboxes.length;i++)if(leightboxes[i].content==name){leightboxes[i].deactivate();break;}
}

function leightbox_activate(name) {
    leightbox_to_activate = name;
    lbox = document.getElementsByClassName('lbOn');

    for(i = 0; i < lbox.length; i++) {
        if (leightboxes[i] && name==leightboxes[i].content) {
            leightboxes[i].activate();
            leightbox_to_activate='';
            break;
        }
    }
}

addLeightboxMarkup();
getBrowserInfo();

function leightbox_reload() {
    if(leightbox_is_active) {
        var lbs = jq('#leightbox_container .leightbox');
        if(lbs.length>0) {
            var id = lbs.attr('id')
            leightbox_deactivate(id);
            leightbox_activate(id);
        }
        return;
    }
    $('leightbox_container').innerHTML = '';
    lbox = document.getElementsByClassName('lbOn');
    for(i = 0; i < leightboxes.length; i++)
        delete(leightboxes[i]);
    for(i = 0; i < lbox.length; i++) {
        lbox[i].stopObserving('click');
        leightboxes[i] = new leightbox(lbox[i]);
        if (leightbox_to_activate==lbox[i].getAttribute("rel")) {
            leightboxes[i].activate();
            leightbox_to_activate='';
        }
    }
}

document.observe("e:load", leightbox_reload);

;function libs_leightbox_resize(elem) {

	var s = elem.style;

	if(s.width == '100%') {
		if($(elem.id+'_bigsize').value==1) {
			s.top = '5%';
			s.left = '5%';
			s.width = '90%';
			s.height = '90%';
		} else {
			s.top = '25%';
			s.left = '15%';
			s.width = '70%';
			s.height = '50%';
		}
		//s.border = '10px solid #b3b3b3';
		s.padding = '0px';
	}

	else {
		s.top = '0px';
		s.left = '0px';
		s.width = '100%';
		s.height = '100%';
		s.border = '0px';
		s.padding = '0px';
	}
}

;/*
CoolClock by Simon Baird (simon dot baird at gmail dot com)
Version 1.0.6 (08-Jul-2008)
See http://simonbaird.com/coolclock/

Copyright (c) Simon Baird 2006-2008

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this
list of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this
list of conditions and the following disclaimer in the documentation and/or other
materials provided with the distribution.

Neither the name of the Simon Baird nor the names of other contributors may be
used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
DAMAGE.
*/

window.CoolClock = function(canvasId,displayRadius,skinId,showSecondHand,gmtOffset) {
	return this.init(canvasId,displayRadius,skinId,showSecondHand,gmtOffset);
}

CoolClock.findAndCreateClocks = function() {
	var canvases = document.getElementsByTagName("canvas");
	for (var i=0;i<canvases.length;i++) {
		var fields = canvases[i].className.split(" ")[0].split(":");
		if (fields[0] == "CoolClock") {
			new CoolClock(canvases[i].id,fields[2],fields[1],fields[3]!="noSeconds",fields[4]);
		}
	}
}

// borrowed from behaviour.js
// actually doesn't work right unless it's at the end of html document
// hence can't have a body onload
// this is a bug. FIXME
// maybe have a setTimeout hack??
CoolClock.addLoadEvent = function(func){
	var oldonload = window.onload;
	if (typeof window.onload != 'function')
		window.onload = func;
	else
		window.onload = function() {
			oldonload();
			func();
		}
}

CoolClock.config = {
	clockTracker: {},
	tickDelay: 1000,
	longTickDelay: 15000,
	defaultRadius: 85,
	renderRadius: 100,
	defaultSkin: "swissRail",
	skins:	{
		// more skins in moreskins.js
		// try making your own...

	swissRail: {
		outerBorder: { lineWidth: 1, radius:95, color: "black", alpha: 1 },
		smallIndicator: { lineWidth: 2, startAt: 89, endAt: 93, color: "black", alpha: 1 },
		largeIndicator: { lineWidth: 4, startAt: 80, endAt: 93, color: "black", alpha: 1 },
		hourHand: { lineWidth: 8, startAt: -15, endAt: 50, color: "black", alpha: 1 },
		minuteHand: { lineWidth: 7, startAt: -15, endAt: 75, color: "black", alpha: 1 },
		secondHand: { lineWidth: 1, startAt: -20, endAt: 85, color: "red", alpha: 1 },
		secondDecoration: { lineWidth: 1, startAt: 70, radius: 4, fillColor: "red", color: "red", alpha: 1 }
	},

	chunkySwiss: {
		outerBorder: { lineWidth: 4, radius:97, color: "black", alpha: 1 },
		smallIndicator: { lineWidth: 4, startAt: 89, endAt: 93, color: "black", alpha: 1 },
		largeIndicator: { lineWidth: 8, startAt: 80, endAt: 93, color: "black", alpha: 1 },
		hourHand: { lineWidth: 12, startAt: -15, endAt: 60, color: "black", alpha: 1 },
		minuteHand: { lineWidth: 10, startAt: -15, endAt: 85, color: "black", alpha: 1 },
		secondHand: { lineWidth: 4, startAt: -20, endAt: 85, color: "red", alpha: 1 },
		secondDecoration: { lineWidth: 2, startAt: 70, radius: 8, fillColor: "red", color: "red", alpha: 1 }
	},

	chunkySwissOnBlack: {
		outerBorder: { lineWidth: 4, radius:97, color: "white", alpha: 1 },
		smallIndicator: { lineWidth: 4, startAt: 89, endAt: 93, color: "white", alpha: 1 },
		largeIndicator: { lineWidth: 8, startAt: 80, endAt: 93, color: "white", alpha: 1 },
		hourHand: { lineWidth: 12, startAt: -15, endAt: 60, color: "white", alpha: 1 },
		minuteHand: { lineWidth: 10, startAt: -15, endAt: 85, color: "white", alpha: 1 },
		secondHand: { lineWidth: 4, startAt: -20, endAt: 85, color: "red", alpha: 1 },
		secondDecoration: { lineWidth: 2, startAt: 70, radius: 8, fillColor: "red", color: "red", alpha: 1 }
	},

	fancy: {
		outerBorder: { lineWidth: 5, radius:95, color: "green", alpha: 0.7 },
		smallIndicator: { lineWidth: 1, startAt: 80, endAt: 93, color: "black", alpha: 0.4 },
		largeIndicator: { lineWidth: 1, startAt: 30, endAt: 93, color: "black", alpha: 0.5 },
		hourHand: { lineWidth: 8, startAt: -15, endAt: 50, color: "blue", alpha: 0.7 },
		minuteHand: { lineWidth: 7, startAt: -15, endAt: 92, color: "red", alpha: 0.7 },
		secondHand: { lineWidth: 10, startAt: 80, endAt: 85, color: "blue", alpha: 0.3 },
		secondDecoration: { lineWidth: 1, startAt: 30, radius: 50, fillColor: "blue", color: "red", alpha: 0.15 }
	},

	machine: {
		outerBorder: { lineWidth: 60, radius:55, color: "#dd6655", alpha: 1 },
		smallIndicator: { lineWidth: 4, startAt: 80, endAt: 95, color: "white", alpha: 1 },
		largeIndicator: { lineWidth: 14, startAt: 77, endAt: 92, color: "#dd6655", alpha: 1 },
		hourHand: { lineWidth: 18, startAt: -15, endAt: 40, color: "white", alpha: 1 },
		minuteHand: { lineWidth: 14, startAt: 24, endAt: 100, color: "#771100", alpha: 0.5 },
		secondHand: { lineWidth: 3, startAt: 22, endAt: 83, color: "green", alpha: 0 },
		secondDecoration: { lineWidth: 1, startAt: 52, radius: 26, fillColor: "#ffcccc", color: "red", alpha: 0.5 }
	},

	// these three created by bonstio from http://bonstio.net
	classic/*was gIG*/: {
		outerBorder: { lineWidth: 185, radius:1, color: "#E5ECF9", alpha: 1 },
		smallIndicator: { lineWidth: 2, startAt: 89, endAt: 94, color: "#3366CC", alpha: 1 },
		largeIndicator: { lineWidth: 4, startAt: 83, endAt: 94, color: "#3366CC", alpha: 1 },
		hourHand: { lineWidth: 5, startAt: 0, endAt: 60, color: "black", alpha: 1 },
		minuteHand: { lineWidth: 4, startAt: 0, endAt: 80, color: "black", alpha: 1 },
		secondHand: { lineWidth: 1, startAt: -20, endAt: 85, color: "red", alpha: .85 },
		secondDecoration: { lineWidth: 3, startAt: 0, radius: 2, fillColor: "black", color: "black", alpha: 1 }
	},

	modern/*was gIG2*/: {
		outerBorder: { lineWidth: 185, radius:1, color: "#E5ECF9", alpha: 1 },
		smallIndicator: { lineWidth: 5, startAt: 88, endAt: 94, color: "#3366CC", alpha: 1 },
		largeIndicator: { lineWidth: 5, startAt: 88, endAt: 94, color: "#3366CC", alpha: 1 },
		hourHand: { lineWidth: 8, startAt: 0, endAt: 60, color: "black", alpha: 1 },
		minuteHand: { lineWidth: 8, startAt: 0, endAt: 80, color: "black", alpha: 1 },
		secondHand: { lineWidth: 5, startAt: 80, endAt: 85, color: "red", alpha: .85 },
		secondDecoration: { lineWidth: 3, startAt: 0, radius: 4, fillColor: "black", color: "black", alpha: 1 }
	},

	simple/*was gIG3*/: {
		outerBorder: { lineWidth: 185, radius:1, color: "#E5ECF9", alpha: 1 },
		smallIndicator: { lineWidth: 10, startAt: 90, endAt: 94, color: "#3366CC", alpha: 1 },
		largeIndicator: { lineWidth: 10, startAt: 90, endAt: 94, color: "#3366CC", alpha: 1 },
		hourHand: { lineWidth: 8, startAt: 0, endAt: 60, color: "black", alpha: 1 },
		minuteHand: { lineWidth: 8, startAt: 0, endAt: 80, color: "black", alpha: 1 },
		secondHand: { lineWidth: 5, startAt: 80, endAt: 85, color: "red", alpha: .85 },
		secondDecoration: { lineWidth: 3, startAt: 0, radius: 4, fillColor: "black", color: "black", alpha: 1 }
	},

	// these two by securephp
	securephp: {
		outerBorder: { lineWidth: 100, radius:0.45, color: "#669900", alpha: 0.3 },
		smallIndicator: { lineWidth: 2, startAt: 80, endAt:90 , color: "green", alpha: 1 },
		largeIndicator: { lineWidth: 8.5, startAt: 20, endAt:40 , color: "green", alpha: 0.4 },
		hourHand: { lineWidth: 3, startAt: 0, endAt: 60, color: "black", alpha: 1 },
		minuteHand: { lineWidth: 2, startAt: 0, endAt: 75, color: "black", alpha: 1 },
		secondHand: { lineWidth: 1, startAt: -10, endAt: 80, color: "blue", alpha: 0.8 },
		secondDecoration: { lineWidth: 1, startAt: 70, radius: 4, fillColor: "blue", color: "red", alpha: 1 }
	},

	Tes2: {
		outerBorder: { lineWidth: 4, radius:95, color: "black", alpha: 0.5 },
		smallIndicator: { lineWidth: 1, startAt: 10, endAt:50 , color: "#66CCFF", alpha: 1 },
		largeIndicator: { lineWidth: 8.5, startAt: 60, endAt: 70, color: "#6699FF", alpha: 1 },
		hourHand: { lineWidth: 5, startAt: -15, endAt: 60, color: "black", alpha: 0.7 },
		minuteHand: { lineWidth: 3, startAt: -25, endAt: 75, color: "black", alpha: 0.7 },
		secondHand: { lineWidth: 1.5, startAt: -20, endAt: 88, color: "red", alpha: 1 },
		secondDecoration: { lineWidth: 1, startAt: 20, radius: 4, fillColor: "blue", color: "red", alpha: 1 }
	},


	Lev: {
	outerBorder: { lineWidth:10, radius:95, color: "#CCFF33", alpha: 0.65 },
	smallIndicator: { lineWidth: 5, startAt: 84, endAt: 90, color: "#996600", alpha: 1 },
	largeIndicator: { lineWidth: 40, startAt: 25, endAt: 95, color: "#336600", alpha: 0.55 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 0.9 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 80, color: "black", alpha: 0.85 },
	secondHand: { lineWidth: 1, startAt: 0, endAt: 85, color: "black", alpha: 1 },
	secondDecoration: { lineWidth: 2, startAt: 5, radius: 10, fillColor: "black", color: "black", alpha: 1 }
	},

	Sand: {
	outerBorder: { lineWidth:1, radius:70, color: "black", alpha: 0.5 },
	smallIndicator: { lineWidth: 3, startAt: 50, endAt: 70, color: "#0066FF", alpha: 0.5 },
	largeIndicator: { lineWidth: 200, startAt: 80, endAt: 95, color: "#996600", alpha: 0.75 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 0.9 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 80, color: "black", alpha: 0.85 },
	secondHand: { lineWidth: 1, startAt: 0, endAt: 85, color: "black", alpha: 1 },
	secondDecoration: { lineWidth: 2, startAt: 5, radius: 10, fillColor: "black", color: "black", alpha: 1 }
	},

	Sun: {
	outerBorder: { lineWidth:100, radius:140, color: "#99FFFF", alpha: 0.2 },
	smallIndicator: { lineWidth: 300, startAt: 50, endAt: 70, color: "black", alpha: 0.1 },
	largeIndicator: { lineWidth: 5, startAt: 80, endAt: 95, color: "black", alpha: 0.65 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 0.9 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 80, color: "black", alpha: 0.85 },
	secondHand: { lineWidth: 1, startAt: 0, endAt: 90, color: "black", alpha: 1 },
	secondDecoration: { lineWidth: 2, startAt: 5, radius: 10, fillColor: "black", color: "black", alpha: 1 }
	},

	Tor: {
	outerBorder: { lineWidth:10, radius:88, color: "#996600", alpha: 0.9 },
	smallIndicator: { lineWidth: 6, startAt: -10, endAt: 73, color: "green", alpha: 0.3 },
	largeIndicator: { lineWidth: 6, startAt: 73, endAt: 100, color: "black", alpha: 0.65 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 1 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 80, color: "black", alpha: 1 },
	secondHand: { lineWidth: 1, startAt: -73, endAt: 73, color: "black", alpha: 0.8 },
	secondDecoration: { lineWidth: 2, startAt: 5, radius: 10, fillColor: "black", color: "black", alpha: 1 }
	},

	Cold: {
	outerBorder: { lineWidth:15, radius:90, color: "black", alpha: 0.3 },
	smallIndicator: { lineWidth: 15, startAt: -10, endAt: 95, color: "blue", alpha: 0.1 },
	largeIndicator: { lineWidth: 3, startAt: 80, endAt: 95, color: "blue", alpha: 0.65 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 1 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 80, color: "black", alpha: 1 },
	secondHand: { lineWidth: 1, startAt: 0, endAt: 85, color: "black", alpha: 0.8 },
	secondDecoration: { lineWidth: 5, startAt: 30, radius: 10, fillColor: "black", color: "black", alpha: 1 }
	},

	Babosa: {
	outerBorder: { lineWidth: 100, radius:25, color: "blue", alpha: 0.25 },
	smallIndicator: { lineWidth: 3, startAt: 90, endAt: 95, color: "#3366CC", alpha: 1 },
	largeIndicator: { lineWidth: 4, startAt: 75, endAt: 95, color: "#3366CC", alpha: 1 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 60, color: "black", alpha: 1 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 85, color: "black", alpha: 1 },
	secondHand: { lineWidth: 12, startAt: 75, endAt: 90, color: "red", alpha: 0.8 },
	secondDecoration: { lineWidth: 3, startAt: 0, radius: 4, fillColor: "black", color: "black", alpha: 1 }
	},

	Tumb: {
	outerBorder: { lineWidth:105, radius:5, color: "green", alpha: 0.4 },
	smallIndicator: { lineWidth: 1, startAt: 93, endAt: 98, color: "green", alpha: 1 },
	largeIndicator: { lineWidth: 50, startAt: 0, endAt: 89, color: "red", alpha: 0.14 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 1 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 80, color: "black", alpha: 1 },
	secondHand: { lineWidth: 1, startAt: 0, endAt: 85, color: "black", alpha: 0.8 },
	secondDecoration: { lineWidth: 5, startAt: 50, radius: 90, fillColor: "black", color: "black", alpha: 0.05 }
	},

	Stone: {
	outerBorder: { lineWidth:15, radius:80, color: "#339933", alpha: 0.5 },
	smallIndicator: { lineWidth: 2, startAt: 70, endAt: 90, color: "#FF3300", alpha: 0.7 },
	largeIndicator: { lineWidth: 15, startAt: 0, endAt: 29, color: "#FF6600", alpha: 0.3 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 1 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 75, color: "black", alpha: 1 },
	secondHand: { lineWidth: 1, startAt: 0, endAt: 85, color: "black", alpha: 0.8 },
	secondDecoration: { lineWidth: 5, startAt: 50, radius: 90, fillColor: "black", color: "black", alpha: 0.05 }
	},

	Disc: {
	outerBorder: { lineWidth:105, radius:1, color: "#666600", alpha: 0.2 },
	smallIndicator: { lineWidth: 1, startAt: 58, endAt: 95, color: "#669900", alpha: 0.8 },
	largeIndicator: { lineWidth: 6, startAt: 25, endAt: 35, color: "#666600", alpha: 1 },
	hourHand: { lineWidth: 4, startAt: 0, endAt: 65, color: "black", alpha: 1 },
	minuteHand: { lineWidth: 3, startAt: 0, endAt: 75, color: "black", alpha: 1 },
	secondHand: { lineWidth: 1, startAt: -75, endAt: 75, color: "#99CC00", alpha: 0.8 },
	secondDecoration: { lineWidth: 5, startAt: 50, radius: 90, fillColor: "#00FF00", color: "green", alpha: 0.05 }
	}

	}
};

CoolClock.prototype = {
	init: function(canvasId,displayRadius,skinId,showSecondHand,gmtOffset) {
		this.canvasId = canvasId;
		this.displayRadius = displayRadius || CoolClock.config.defaultRadius;
		this.skinId = skinId || CoolClock.config.defaultSkin;
		this.showSecondHand = typeof showSecondHand == "boolean" ? showSecondHand : true;
		this.tickDelay = CoolClock.config[ this.showSecondHand ? "tickDelay" : "longTickDelay"];

		this.canvas = document.getElementById(canvasId);

		this.canvas.setAttribute("width",this.displayRadius*2);
		this.canvas.setAttribute("height",this.displayRadius*2);

		this.canvas.style.width = this.displayRadius*2 + "px";
		this.canvas.style.height = this.displayRadius*2 + "px";

		this.renderRadius = CoolClock.config.renderRadius; 

		this.scale = this.displayRadius / this.renderRadius;
		this.ctx = this.canvas.getContext("2d");
		this.ctx.scale(this.scale,this.scale);

		this.gmtOffset = gmtOffset != null ? parseFloat(gmtOffset) : gmtOffset;

		CoolClock.config.clockTracker[canvasId] = this;
		this.tick();
		return this;
	},

	fullCircle: function(skin) {
		this.fullCircleAt(this.renderRadius,this.renderRadius,skin);
	},

	fullCircleAt: function(x,y,skin) {
		with (this.ctx) {
			save();
			globalAlpha = skin.alpha;
			lineWidth = skin.lineWidth;
			if (!document.all)
				beginPath();
			if (document.all)
				// excanvas doesn't scale line width so we will do it here
				lineWidth = lineWidth * this.scale;
			arc(x, y, skin.radius, 0, 2*Math.PI, false);
			if (document.all)
				// excanvas doesn't close the circle so let's color in the gap
				arc(x, y, skin.radius, -0.1, 0.1, false);
			if (skin.fillColor) {
				fillStyle = skin.fillColor
				fill();
			}
			else {
				// XXX why not stroke and fill
				strokeStyle = skin.color;
				stroke();
			}
			restore();
		}
	},

	radialLineAtAngle: function(angleFraction,skin) {
		with (this.ctx) {
			save();
			translate(this.renderRadius,this.renderRadius);
			rotate(Math.PI * (2 * angleFraction - 0.5));
			globalAlpha = skin.alpha;
			strokeStyle = skin.color;
			lineWidth = skin.lineWidth;
			if (document.all)
				// excanvas doesn't scale line width so we will do it here
				lineWidth = lineWidth * this.scale;
			if (skin.radius) {
				this.fullCircleAt(skin.startAt,0,skin)
			}
			else {
				beginPath();
				moveTo(skin.startAt,0)
				lineTo(skin.endAt,0);
				stroke();
			}
			restore();
		}
	},

	render: function(hour,min,sec) {
		var skin = CoolClock.config.skins[this.skinId];
		this.ctx.clearRect(0,0,this.renderRadius*2,this.renderRadius*2);

		this.fullCircle(skin.outerBorder);

		for (var i=0;i<60;i++)
			this.radialLineAtAngle(i/60,skin[ i%5 ? "smallIndicator" : "largeIndicator"]);
				
		this.radialLineAtAngle((hour+min/60)/12,skin.hourHand);
		this.radialLineAtAngle((min+sec/60)/60,skin.minuteHand);
		if (this.showSecondHand) {
			this.radialLineAtAngle(sec/60,skin.secondHand);
			if (!document.all)
				// decoration doesn't render right in IE so lets turn it off
				this.radialLineAtAngle(sec/60,skin.secondDecoration);
		}
	},


	nextTick: function() {
		setTimeout("CoolClock.config.clockTracker['"+this.canvasId+"'].tick()",this.tickDelay);
	},

	stillHere: function() {
		return document.getElementById(this.canvasId) != null;
	},

	refreshDisplay: function() {
		var now = new Date();
		if (this.gmtOffset != null) {
			// use GMT + gmtOffset
			var offsetNow = new Date(now.valueOf() + (this.gmtOffset * 1000 * 60 * 60));
			this.render(offsetNow.getUTCHours(),offsetNow.getUTCMinutes(),offsetNow.getUTCSeconds());
		}
		else {
			// use local time
			this.render(now.getHours(),now.getMinutes(),now.getSeconds());
		}
	},

	tick: function() {
		if (this.stillHere()) {
			this.refreshDisplay()
			this.nextTick();
		}
	}
}

CoolClock.addLoadEvent(CoolClock.findAndCreateClocks);


;var Utils_PopupCalendar = function(link_proto, instance_id, mode,first_day_of_week, month_names, day_names) {
		this.monthName = month_names;
		this.link_proto = link_proto;
		this.selected = 0;
		this.instance_id = instance_id;
		if(typeof mode == 'undefined') mode='day';
		this.mode = mode;
		this.first_day_of_week = first_day_of_week;
		if(typeof first_day_of_week == 'undefined')
			this.first_day_of_week = 0;
		else
			this.first_day_of_week = parseInt(this.first_day_of_week);

		//show calendar
		this.show = function(year, month, day) {
			switch(this.mode) {
				case 'year':
					this.show_decade();
					break;
				case 'month':
					this.show_year(year);
					break;
				case 'day':
				default:
					this.show_month(year, month, day);
			}
		}

		// show a month
		this.show_month = function( year, month, day ) {
			if (!this.selected && year && month && day) {
				this.selected = new Date();
				this.selected.setDate(day);
				this.selected.setMonth(month);
				this.selected.setYear(year);
			}
			var days = day_names;
            var daysInMonth = null;
			var daysInWeek = 7;

			// formatting constants
			var TRstart = '<tr>';
			var TRend = '</tr>';
			var TDstartHL = '<td class="today">';
			var TDstart = '<td>';
			var TDend = '</td>';
			var empty = '<td class="empty">&nbsp;</td>';

			// preparing date
			var Calendar = new Date();
			var current_day = Calendar.getDate();
			var current_month = Calendar.getMonth();
			var current_year = Calendar.getFullYear();
			if( typeof month == "undefined" ) { month = Calendar.getMonth(); } else { month = month * 1; }
			var prev_month = month - 1;
			var next_month = month + 1;
			if( typeof year == "undefined" ) { year = Calendar.getFullYear(); } else { year = year * 1; }

            if(year%400==0 || (year%100!=0 && year%4==0))
            	daysInMonth = new Array(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
            else
            	daysInMonth = new Array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);

			year_real = year;
			var prev_year = year;
			if(prev_month < 0) { prev_month = 11; prev_year--; }
			var next_year = year;
			if(next_month > 11) { next_month = 0; next_year++; }

			// filling header
			var header_string = '<table class="menu" cellspacing="0" cellpadding="0" border="0"><tr>';
			header_string += '<td class="prev"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_month(\''+prev_year+'\', \''+prev_month+'\')">&lt;&lt</a></td>';
			header_string += '<td class="label"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_year(\''+year+'\')">'+this.monthName[month] + ' ' + year_real+'</a></td>';
			header_string += '<td class="next"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_month(\''+next_year+'\', \''+next_month+'\')">&gt;&gt</a></td>';
			header_string += '<td class="close"><a href="javascript:void(0)" onClick="$(\'datepicker_'+this.instance_id+'_calendar\').toggle()">X</a></td>';
			header_string += '</tr></table>';
			$('datepicker_'+this.instance_id+'_header').innerHTML = header_string;

			// filling month
			Calendar.setDate(1);
			Calendar.setMonth( month );
			Calendar.setYear( year_real );
			var cal = '';
			cal += '<table cellspacing="0" cellpadding="0" border="0" class="small">' + TRstart;

			// days' names
			for(index = 0; index < 7; index++) {
				cal += '<td class="daysHeader">' + days[(index+this.first_day_of_week)%7] + TDend;
			}
			cal += TRend + TRstart+'<td class="spacerTop" colspan="'+daysInWeek+'"><p class="pt"></p></td>'+TRend+TRstart;

			// blanks before first day of the month
			var tmp = Calendar.getDay();
			if( tmp == 0 ) { tmp = 7; }
			for(index = this.first_day_of_week; index < tmp ; index++) {
//			for(index = 1; index < tmp ; index++) {
				cal += empty;
			}
			var weekday;
			for(index = 0; index < daysInMonth[month]; index++)	{
				weekday = Calendar.getDay();
				//if(weekday == 1) { cal += TRstart; }
				if(weekday == this.first_day_of_week) { cal += TRstart; }

				cal += '<td class="';
				if( (current_day == Calendar.getDate()) && (current_month == month) && (current_year == year) )
					cal += 'today ';
				if( weekday % 6 < 1 )
					cal += 'weekend ';
				if( this.selected &&
					(Calendar.getDate() == this.selected.getDate()) && 
					(Calendar.getMonth() == this.selected.getMonth()) && 
					(Calendar.getFullYear() == this.selected.getFullYear()) )
					cal += 'selected ';
				cal += '">';
				//cal += '<a class=day href="javascript:get_date('+year_real+', '+(month+1)+', '+Calendar.getDate()+', \''+this.field+'\', \''+this.format+'\')">';
				var prep_link = this.link_proto.replace("__YEAR__", year_real);
				prep_link = prep_link.replace("__MONTH__", (month+1));
				prep_link = prep_link.replace("__DAY__", Calendar.getDate());
				cal += '<div class="day"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.selected = new Date('+Calendar.getFullYear()+','+Calendar.getMonth()+','+Calendar.getDate()+');datepicker_'+this.instance_id+'.show_month('+year+','+month+','+day+');'+prep_link+'">';
				cal += Calendar.getDate();
				cal += '</a></div>' + TDend;

//				if(weekday == 0) { cal += TRend; }
				if(weekday == (this.first_day_of_week+6)%7) { cal += TRend; }
				Calendar.setDate(Calendar.getDate()+1);
			} // end for loop

			if( weekday < daysInWeek ) {
				for(index = weekday+1; index < (Calendar.getDay()+6)%7; index++) {
					cal += empty;
				}
				cal += TRend+TRstart+'<td class=spacerBottom colspan='+daysInWeek+'><p class=pt></p></td>'+TRend;
			}
			cal += '</TABLE>';
			// and final solution
			$('datepicker_'+this.instance_id+'_view').innerHTML = cal;
		}

		//show a year
		this.show_year = function( year ) {
			// formatting constants
			var TRstart = '<tr>';
			var TRend = '</tr>';
			var TDstartHL = '<td class=today>';
			var TDstart = '<td>';
			var TDend = '</td>';

			// preparing date
			var Calendar = new Date();
			var current_month = Calendar.getMonth();
			var current_year = Calendar.getFullYear();
			if( !year ) { year = Calendar.getFullYear(); } else { year = year * 1; }
			year_real = year;
			var prev_year = year - 1;
			var next_year = year + 1;

			// filling header
			var header_string = '<table class="menu" cellspacing="0" cellpadding="0" border="0"><tr>';
			header_string += '<td class="prev"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_year(\''+prev_year+'\')">&lt;&lt</a></td>';
			header_string += '<td class="label"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_decade(\''+(year - (year%10))+'\')">'+ year_real+'</a></td>';
			header_string += '<td class="next"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_year(\''+next_year+'\')">&gt;&gt</a></td>';
			header_string += '<td class="close"><a href="javascript:void(0)" onClick="$(\'datepicker_'+this.instance_id+'_calendar\').toggle()">X</a></td>';
			header_string += '</tr></table>';
			document.getElementById('datepicker_'+this.instance_id+'_header').innerHTML = header_string;

			// filling year with months
			var cal = '';
			cal += '<table cellspacing="0" cellpadding="0" border="0" class="small">';
			for(index = 0; index < 12; index++)	{
				if( index % 3 == 0 ) { cal += TRstart; }

				cal += '<td ';
				if( (current_month == index) && (current_year == year) ) {
						cal += ' class=today>';
				} else {
					cal += '>';
				}
				var prep_link;
				if(this.mode!='month') {
					prep_link = 'datepicker_'+this.instance_id+'.show_month('+year+', '+index+')';
				} else {
					prep_link = this.link_proto.replace("__YEAR__", year_real);
					prep_link = prep_link.replace("__MONTH__", (index+1));
					prep_link = prep_link.replace("__DAY__", '1');
				}
				cal += '<div class="month"><a href="javascript:void(0)" onClick="'+prep_link+'">';
				cal += this.monthName[index];
				cal += '</a></div>' + TDend;

				if(index % 3 == 2) { cal += TRend; }
			} // end for loop

			cal += '</TABLE>';
			// and final solution
			document.getElementById('datepicker_'+this.instance_id+'_view').innerHTML = cal;
		}

		//show a decade
		this.show_decade = function( decade ) {
			// formatting constants
			var TRstart = '<tr>';
			var TRend = '</tr>';
			var TDstartHL = '<td class=today>';
			var TDstart = '<td>';
			var TDend = '</td>';

			// preparing date
			var Calendar = new Date();
			var current_year = Calendar.getFullYear();
			if( !decade ) { decade = Calendar.getFullYear(); } else { decade = decade * 1; }
			decade_real = decade;
			var prev_decade = decade - 10;
			var next_decade = decade + 10;

			// filling header
			var header_string = '<table class="menu"  cellspacing="0" cellpadding="0" border="0"><tr>';
			header_string += '<td class="prev"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_decade(\''+prev_decade+'\')">&lt;&lt</a></td>';
			header_string += '<td class="label"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_century(\''+(decade - (decade%100))+'\')">'+ decade_real + ' - ' + (decade_real+10) + '</a></td>';
			header_string += '<td class="next"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_decade(\''+next_decade+'\')">&gt;&gt</a></td>';
			header_string += '<td class="close"><a href="javascript:void(0)" onClick="$(\'datepicker_'+this.instance_id+'_calendar\').toggle()">X</a></td>';
			header_string += '</tr></table>';
			document.getElementById('datepicker_'+this.instance_id+'_header').innerHTML = header_string;

			// filling year with months
			var cal = '';
			cal += '<table cellspacing="0" cellpadding="0" border="0" class="small">';
			for(index = 0; index < 12; index++)	{
				if( index % 3 == 0 ) { cal += TRstart; }

				cal += '<td ';
				if( current_year == decade + index -1 ) {
						cal += ' class=today>';
				} else {
					cal += '>';
				}
				var prep_link;
				if(this.mode!='year') {
					prep_link = 'datepicker_'+this.instance_id+'.show_year('+(decade+index-1)+')';
				} else {
					prep_link = this.link_proto.replace("__YEAR__", (decade_real+index-1));
					prep_link = prep_link.replace("__MONTH__", '1');
					prep_link = prep_link.replace("__DAY__", '1');
				}
				cal += '<div class="month"><a href="javascript:void(0)" onClick="'+prep_link+'">';
				cal += (decade_real + index - 1);
				cal += '</a></div>' + TDend;

				if(index % 3 == 2) { cal += TRend; }
			} // end for loop

			cal += '</TABLE>';
			// and final solution
			document.getElementById('datepicker_'+this.instance_id+'_view').innerHTML = cal;
		}

		//show a century
		this.show_century = function( century ) {
			// formatting constants
			var TRstart = '<tr>';
			var TRend = '</tr>';
			var TDstartHL = '<td class=today>';
			var TDstart = '<td>';
			var TDend = '</td>';

			// preparing date
			var Calendar = new Date();
			var current_year = Calendar.getFullYear();
			if( !century ) { century = Calendar.getFullYear(); } else { century = century * 1; }
			century_real = century;
			var prev_century = century - 100;
			var next_century = century + 100;

			// filling header
			var header_string = '<table class="menu" cellspacing="0" cellpadding="0" border="0"><tr>';
			header_string += '<td class="prev"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_century(\''+prev_century+'\')">&lt;&lt</a></td>';
			header_string += '<td class="label">'+ century_real + ' - ' + (century_real+100) + '</td>';
			header_string += '<td class="next"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_century(\''+next_century+'\')">&gt;&gt</a></td>';
			header_string += '<td class="close"><a href="javascript:void(0)" onClick="$(\'datepicker_'+this.instance_id+'_calendar\').toggle()">X</a></td>';
			header_string += '</tr></table>';
			document.getElementById('datepicker_'+this.instance_id+'_header').innerHTML = header_string;

			// filling year with months
			var cal = '';
			cal += '<table cellspacing="0" cellpadding="0" border="0" class="small">';
			for(index = 0; index < 120; index += 10)	{
				if( index % 30 == 0 ) { cal += TRstart; }

				cal += '<td ';
				if( (current_year > century + index - 10) && (century + index > current_year) ) {
						cal += ' class=today>';
				} else {
					cal += '>';
				}
				cal += '<div class="month"><a href="javascript:void(0)" onClick="datepicker_'+this.instance_id+'.show_decade(' + (century + index - 10) + ')">';
				cal += (century_real + index - 10) + '&nbsp;-&nbsp;' + (century_real + index);
				cal += '</a></div>' + TDend;

				if(index % 30 == 20) { cal += TRend; }
			} // end for loop

			cal += '</TABLE>';
			// and final solution
			document.getElementById('datepicker_'+this.instance_id+'_view').innerHTML = cal;
		}
	}

;var Utils_PopupCalendarDatePicker = {
format:null,
re:null,
validate: function(ev,f) {
	var elem = Event.element(ev);
	var val = elem.value;
	var key = ev.which;
	if(!(key>=32 && key<=126)) return;
	var car = this.get_caret(elem);
	val = val.substring(0,car)+String.fromCharCode(key)+val.substring(car);
	this.init_re(f);
	if(!this.re.test(val))
		Event.stop(ev);
	if(!this.re.test(elem.value)) {
		alert('Invalid date - clearing');
		elem.value='';
	}
},
validate_blur: function(ev,f) {
	var elem = Event.element(ev);
	this.init_re(f);
	if(!this.re.test(elem.value)) {
		alert('Invalid date - clearing');
		elem.value='';
	}
},
init_re: function(f) {
	if(this.format!=f) {
		this.re = new RegExp();
//		alert(this.format2regexp(f));
		this.re.compile('^'+this.format2regexp(f)+'$');
		this.format=f;
	}
},
format2regexp: function(f) {
	return f.replace(new RegExp('^([%a-zA-Z/]+)/([%a-zA-Z/]+)$','g'),"$1(/$2)?")
		.replace(new RegExp('^([%a-zA-Z/]+)/([%a-zA-Z/?()]+)$','g'),"$1(/$2)?")
		.replace(new RegExp('^([%a-zA-Z-]+)-([%a-zA-Z-]+)$','g'),"$1(-$2)?")
		.replace(new RegExp('^([%a-zA-Z-]+)-([%a-zA-Z-?()]+)$','g'),"$1(-$2)?")
		.replace(new RegExp('^([%a-zA-Z ,]+) ([%a-zA-Z ]+)$','g'),"$1( $2)?")
		.replace(new RegExp('^([%a-zA-Z ]+),([%a-zA-Z ?()]+)$','g'),"$1(,$2)?")
		.replace(new RegExp('^([%a-zA-Z ]+) ([%a-zA-Z ?(),]+)$','g'),"$1( $2)?")
		.replace('%d','[0-3]?[0-9]?')
		.replace('%m','[0-1]?[0-9]?')
		.replace('%y','[0-9]{0,2}')
		.replace('%Y','[0-9]{0,4}')
		.replace('%b','[a-zA-ZáéíóäëöúàèììùąśżźćółńĄŚŻŹĆÓŁŃ]{0,3}')
		.replace('%B','[a-zA-ZáéíóäëöúàèììùąśżźćółńĄŚŻŹĆÓŁŃ]+');
},
// get_caret method based on work of:
// Author: Mihai Bazon, 2006
// http://www.bazon.net/mishoo/
// This code is (c) Dynarch.com, 2006.
// GNU LGPL. (www.gnu.org/licenses/lgpl.html)
get_caret: function(input) {
	if (Prototype.Browser.Gecko)
		return input.selectionEnd;
	var range = document.selection.createRange();
	var isCollapsed = range.compareEndPoints("StartToEnd", range) == 0;
	if (!isCollapsed)
		range.collapse(false);
	var b = range.getBookmark();
	return b.charCodeAt(2) - 2;
}
}



;timeout = new Array();
timeout_hideAllNow = new Array();
last_open = new Array();
level = new Array();
level[-1] = -1;
a_submenu_number = new Array();
a_menu_number = 0;
is_over = new Array();
menu_string = new Array();
layout = new Array();


sub_name = function(menu, submenu) {
	return 'custom_submenu_'+menu+'_'+submenu;
}
opener_name = function(menu, submenu) {
	return 'custom_opener_'+menu+'_'+submenu;
}

hideAllNow = function(menu, submenu) {
	var tmp_id;
	for(i = 0; i < a_submenu_number[menu]; i++ ) {
		tmp_id = sub_name(menu, i);
		if( is_over[menu][i] == 0 && $(tmp_id) && level[menu][submenu] <= level[menu][i] ) {
			$(tmp_id).style.display = "none";
			clearTimeout(timeout[menu][i]);
		}
	}
	last_open[menu] = -1;
}

selected_menu_item = function(menu, a_tag) {
	new Effect.Morph(a_tag, {
		style: 'background-color: #4FD64F;',
		duration: 0.3
	});
	new Effect.Morph(a_tag, {
		style: 'background-color: #4F864F;',
		duration: 0.3,
		delay: 0.3,
		afterFinish: function() {a_tag.style.backgroundColor = "";}
	});
	setTimeout("hideAllNow(\'"+menu+"\', 0);", 600);
}

custom_show = function(menu, submenu) {
	if(timeout[menu][submenu] != null) {
		clearTimeout(timeout[menu][submenu]);
	}

	if(level[menu][submenu] >= level[menu][last_open]) {
		last_open[menu] = submenu;
	}
	var id = sub_name(menu, submenu);
	var opener = opener_name(menu, submenu);
	var elem = $(id);

	elem.style.opacity = 1;
	elem.style.display  = "block";
	if (elem.getAttribute('mi') == null) {
		elem.setAttribute('mi','1');
		if(Epesi.ie)
        		elem.style.position = 'fixed';
		else
        		elem.style.position = 'absolute';
		elem.style.zIndex = 1000;
		//elem.clonePosition(elem.parentNode,{setWidth:false, setHeight:false, offsetTop:0});
		// above line, when commented out, fixed the major menu issue with rtl direction, both lrt and rtl works perfectly well with this line out, on IE, Firefox and Chrome
	}
}

custom_hide_f = function(menu, submenu, opacity) {
	var id = sub_name(menu, submenu);
	if( $(id) ) {
		if(opacity <= 0) {
			clearTimeout(timeout[menu][submenu]);
			$(id).className = "submenu";
			$(id).style.opacity = 1;
			$(id).style.display = "none";
		} else {
			$(id).style.opacity = opacity;
			timeout[menu][submenu] = setTimeout('custom_hide_f(\''+menu+'\', '+submenu+', '+eval(opacity-0.10)+')', 15);
		}
	}
}

custom_hide = function(menu, submenu) {
	timeout[menu][submenu] = setTimeout('custom_hide_f(\''+menu+'\', '+submenu+', 1)', 300);
}
//////////////////////////////////////////////////////////////////////////////
CustomMenubar = function(id, _layout) {
	this.id = id;
	a_menu_number = id;
	menu_string[this.id] = '<table cellspacing=0 cellpadding=0 class=root>';
	layout[this.id] = _layout;
	if( layout[this.id] == 'horizontal' ) {
		menu_string[this.id] += '<tr>';
	}
	this.submenu_number = 0;
	this.depth = 0;
	last_open[this.id] = -1;
	level[this.id] = new Array();
	is_over[this.id] = new Array();
	timeout[this.id] = new Array();
	this.init = 1;

	this.addSplit = function( ) {
		if(layout[this.id] == 'vertical' || this.depth != 0) {
			menu_string[this.id] += '<tr><td class="splitter"></td></tr>'; /*<hr class=custom_split>*/
		} else {
			if(this.depth == 0 ) {
				if(this.init == 0) {
					menu_string[this.id] += '<td class="separator">&nbsp;</td>';
					this.init = 0;
				} else {
					this.init = 0;
				}
				menu_string[this.id] += '<td class=item><a class=root_item_link>-|||-</a></td>';
			}
		}
	}
	this.addLink = function( title, address, icon, target, id) {
		if(layout[this.id] == 'vertical' || this.depth != 0) {
			menu_string[this.id] += '<tr><td class=item>';
			if(icon) {
				menu_string[this.id] += '<div class=link_icon_box><img class=link_icon src="'+icon+'"></div>';
			}
			menu_string[this.id] += '<a href="'+address+'"';
			if (target)
				menu_string[this.id] += ' target="'+target+'"';
			menu_string[this.id] += ' class=root_item_link helpID="'+id+'" onclick="selected_menu_item(\''+this.id+'\', this)">' + title + '</a>';
			menu_string[this.id] += '</td></tr>';
		} else {
			if(this.depth == 0 ) {
				if(this.init == 0) {
					menu_string[this.id] += '<td class="separator">&nbsp;</td>';
					this.init = 0;
				} else {
					this.init = 0;
				}

				menu_string[this.id] += '<td class=item>';
				if(icon) {
					menu_string[this.id] += '<div class=link_icon_box><img class=link_icon src="'+icon+'"></div>';
				}
				if( this.depth == 0) {
					menu_string[this.id] += '<a href="'+address+'" class=root_item_link_none helpID="'+id+'" onclick="selected_menu_item(\''+this.id+'\', this)">' + title + '</a>';
				} else {
					menu_string[this.id] += '<a href="'+address+'" class=root_item_link helpID="'+id+'" onclick="selected_menu_item(\''+this.id+'\', this)">' + title + '</a>';
				}
				menu_string[this.id] += '</td>';
			}
		}
	}
	this.addLink_bullet = function( title, icon, id ) {
		menu_string[this.id] += '<td id="'+opener_name(this.id, this.submenu_number)+'" class=item onmouseover="hideAllNow(\''+this.id+'\','+this.submenu_number+')">';
		if(icon) {
			menu_string[this.id] += '<div class=link_icon_box><img class=link_icon src="'+icon+'"></div>';
		}
		if(layout[this.id] == 'horizontal' && this.depth == 0) {
			menu_string[this.id] += '<a class=root_item_link_down><div class=root_item_link_down_arrow_box helpID="'+id+'"><div class=root_item_link_down_arrow_icon></div><div class=root_item_link_down_arrow>' + title + '</div></div></a>';
		} else {
			menu_string[this.id] += '<a class=root_item_link_right><div class=root_item_link_right_arrow helpID="'+id+'">' + title + '</div></a>';
		}
		menu_string[this.id] += '</td>';

		//<div class=root_item_link_right_arrow>' + title + '</div>
	}

	this.beginSubmenu = function( title, icon, id ) {
		if(layout[this.id] == 'vertical' || this.depth != 0) {
			menu_string[this.id] += '<tr><td>';
			menu_string[this.id] += '<table cellspacing=0 cellpadding=0 onmouseout="custom_hide(\''+this.id+'\','+this.submenu_number+')" onmouseover="custom_show(\''+this.id+'\','+this.submenu_number+')" class=custom_opener>';
			menu_string[this.id] += '<tr>';
			this.addLink_bullet( title, icon, id );
			menu_string[this.id] += '<td class="item_sub">';
			// t2 begin
			menu_string[this.id] += '<table cellspacing="0" cellpadding="0" class="submenu" id="'+sub_name(this.id, this.submenu_number)+'">';
			// --
		} else {
			if(this.depth == 0 ) {
				if(this.init == 0) {
					menu_string[this.id] += '<td class="separator">&nbsp;</td>';
					this.init = 0;
				} else {
					this.init = 0;
				}
				menu_string[this.id] += '<td>';
				menu_string[this.id] += '<table cellspacing=0 cellpadding=0 onmouseout="custom_hide(\''+this.id+'\','+this.submenu_number+')" onmouseover="custom_show(\''+this.id+'\','+this.submenu_number+')" class=custom_opener>';
				menu_string[this.id] += '<tr>';
				this.addLink_bullet( title, icon, id );
				menu_string[this.id] += '</tr><tr><td class=item_sub><table cellspacing=0 cellpadding=0 id="'+sub_name(this.id, this.submenu_number)+'" class=submenu>';
			}
		}
		is_over[this.id][this.submenu_number] = 0;
		level[this.id][this.submenu_number] = this.depth;
		this.submenu_number++;
		this.depth++;
		a_submenu_number[this.id] = this.submenu_number;
	}

	this.endSubmenu = function() {
		this.depth--;
		if(layout[this.id] == 'vertical' || this.depth != 0) {
			// --
			menu_string[this.id] += '</table>';
			// t2 end
			menu_string[this.id] += '</td></tr></table></td></tr>';
		} else {
			if(this.depth == 0 ) {
				menu_string[this.id] += '</table></td></tr></table></td>';
			}
		}
	}

}
//////////////////////////////////////////////////////////////////////////////
writeOut = function(menu) {
	if( layout[menu] == 'horizontal' ) {
		menu_string[menu] += '</tr>';
	}
	$('menu_contener_' + menu).innerHTML = menu_string[menu] + '</table>' ;
}

;'use strict';
// Copyright Patrick Horgan patrick at dbp-consulting dot com
// Permission to use granted as long as you keep this notice intact
// use strict is everywhere because some browsers still don't support
// using it once for the whole file and need per method/function
// use.
// Part is derivitive of work by Juan Mendes as noted below as appropriate.
// Some things depend on code in http://dbp-consulting/scripts/utilities.js

CanvasRenderingContext2D.prototype.roundedRect = 
		function(x, y, width, height, radius, fill, stroke) {
    // This was originally written by Juan Mendes and I have
    // modified it a tiny bit here and there, i.e. added the
    // ctx.save and ctx.restore, so that it can be called without
    // regard to side-effects, and moved the stroke after the fill,
    // because otherwise the fill messes up the stroke which follows the
    // edge with half its width inside the rectangle and half its width
    // outside the rectangle.  The part inside the rectangle is overdrawn
    // with the fill if it comes first.
    // Check out his blog at http://js-bits.blogspot.com
    // The tl (top left), tr (top right), br (bottom right), bl (bottom left)
    // are unnamed optional arguments.
    //     false or unset - rounded corner
    //     true           - square corner
    'use strict';
    var tl=arguments[7];
    var tr=arguments[8];
    var br=arguments[9];
    var bl=arguments[10];

    // default stroke and radius but not fill since its default
    // is false, and undefined tests as false anyway.

    if (typeof stroke == "undefined" ) { stroke = true; } 
    if (typeof radius === "undefined") { radius = 5; }

    this.save()
    //do the line for the top
    this.beginPath();
    this.moveTo(x+radius,y);
    this.lineTo(x+width-radius,y);
    //now the top right corner
    if(!tr){
	this.quadraticCurveTo(x+width,y,x+width,y+radius);
    }else{
	this.lineTo(x+width,y);
	this.lineTo(x+width,y+radius);
    }
    //now right right side
    this.lineTo(x+width,y+height-radius);
    //now the bottom left corner
    if(!br){
	this.quadraticCurveTo(x+width,y+height,x+width-radius,y+height);
    }else{
	this.lineTo(x+width,y+height);
	this.lineTo(x+width-radius,y+height);
    }
    //now the bottom line
    this.lineTo(x+radius,y+height);
    // now the bottom left corner
    if(!bl){
	this.quadraticCurveTo(x,y+height,x,y+height-radius);
    }else{
	this.lineTo(x,y+height);
	this.lineTo(x,y+height-radius);
    }
    //left side line
    this.lineTo(x,y+radius);
    //top left corner
    if(!tl){
	this.quadraticCurveTo(x,y,x+radius,y);
    }else{
	this.lineTo(x,y);
	this.lineTo(x+radius,y);
    }
    // shouldn't need to close it, we just did, but defensively...
    this.closePath();

    // fill it if they asked
    if (fill) { this.fill(); }        

    //then draw a stroke around the path
    if (stroke) { this.stroke(); }

    //put everything back like we found it.
    this.restore();
}

var drawLineAngle=function(ctx,x0,y0,angle,length)
{
    ctx.save();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x0+length*Math.cos(angle),y0+length*Math.sin(angle));
    ctx.stroke();
    ctx.restore();
}
      
var drawHead=function(ctx,x0,y0,x1,y1,x2,y2,style)
{
  'use strict';
  // all cases do this.
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(x0,y0);
  ctx.lineTo(x1,y1);
  ctx.lineTo(x2,y2);
  switch(style){
    case 0:
      // curved filled, add the bottom as an arcTo curve and fill
      var backdist=Math.sqrt(((x2-x0)*(x2-x0))+((y2-y0)*(y2-y0)));
      ctx.arcTo(x1,y1,x0,y0,.55*backdist);
      ctx.fill();
      break;
    case 1:
      // straight filled, add the bottom as a line and fill.
      ctx.lineTo(x0,y0);
      ctx.fill();
      break;
    case 2:
      // unfilled head, just stroke.
      ctx.stroke();
      break;
    case 3:
      //filled head, add the bottom as a quadraticCurveTo curve and fill
      var cpx=(x0+x1+x2)/3;
      var cpy=(y0+y1+y2)/3;
      ctx.quadraticCurveTo(cpx,cpy,x0,y0);
      ctx.fill();
      break;
    case 4:
      //filled head, add the bottom as a bezierCurveTo curve and fill
      var cp1x, cp1y, cp2x, cp2y,backdist;
      var shiftamt=5;
      if(x2==x0){
	// Avoid a divide by zero if x2==x0
	backdist=y2-y0;
	cp1x=(x1+x0)/2;
	cp2x=(x1+x0)/2;
	cp1y=y1+backdist/shiftamt;
	cp2y=y1-backdist/shiftamt;
      }else{
	backdist=Math.sqrt(((x2-x0)*(x2-x0))+((y2-y0)*(y2-y0)));
	var xback=(x0+x2)/2;
	var yback=(y0+y2)/2;
	var xmid=(xback+x1)/2;
	var ymid=(yback+y1)/2;

	var m=(y2-y0)/(x2-x0);
	var dx=(backdist/(2*Math.sqrt(m*m+1)))/shiftamt;
	var dy=m*dx;
	cp1x=xmid-dx;
	cp1y=ymid-dy;
	cp2x=xmid+dx;
	cp2y=ymid+dy;
      }

      ctx.bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x0,y0);
      ctx.fill();
      break;
  }
  ctx.restore();
};

var drawArcedArrow=function(ctx,x,y,r,startangle,endangle,anticlockwise,style,which,angle,d)
{
    'use strict';
    style=typeof(style)!='undefined'? style:3;
    which=typeof(which)!='undefined'? which:1; // end point gets arrow
    angle=typeof(angle)!='undefined'? angle:Math.PI/8;
    d    =typeof(d)    !='undefined'? d    :10;
    ctx.save();
    ctx.beginPath();
    ctx.arc(x,y,r,startangle,endangle,anticlockwise);
    ctx.stroke();
    var sx,sy,lineangle,destx,desty;
    ctx.strokeStyle='rgba(0,0,0,0)';	// don't show the shaft
    if(which&1){	    // draw the destination end
	sx=Math.cos(startangle)*r+x;
	sy=Math.sin(startangle)*r+y;
	lineangle=Math.atan2(x-sx,sy-y);
	if(anticlockwise){
	    destx=sx+10*Math.cos(lineangle);
	    desty=sy+10*Math.sin(lineangle);
	}else{
	    destx=sx-10*Math.cos(lineangle);
	    desty=sy-10*Math.sin(lineangle);
	}
	drawArrow(ctx,sx,sy,destx,desty,style,2,angle,d);
    }
    if(which&2){	    // draw the origination end
	sx=Math.cos(endangle)*r+x;
	sy=Math.sin(endangle)*r+y;
	lineangle=Math.atan2(x-sx,sy-y);
	if(anticlockwise){
	    destx=sx-10*Math.cos(lineangle);
	    desty=sy-10*Math.sin(lineangle);
	}else{
	    destx=sx+10*Math.cos(lineangle);
	    desty=sy+10*Math.sin(lineangle);
	}
	drawArrow(ctx,sx,sy,destx,desty,style,2,angle,d);
    }
    ctx.restore();
}

var drawArrow=function(ctx,x1,y1,x2,y2,style,which,angle,d)
{
  'use strict';
  style=typeof(style)!='undefined'? style:3;
  which=typeof(which)!='undefined'? which:1; // end point gets arrow
  angle=typeof(angle)!='undefined'? angle:Math.PI/8;
  d    =typeof(d)    !='undefined'? d    :10;
  // default to using drawHead to draw the head, but if the style
  // argument is a function, use it instead
  var toDrawHead=typeof(style)!='function'?drawHead:style;

  // For ends with arrow we actually want to stop before we get to the arrow
  // so that wide lines won't put a flat end on the arrow.
  //
  var dist=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
  var ratio=(dist-d/3)/dist;
  var tox, toy,fromx,fromy;
  if(which&1){
    tox=x1+(x2-x1)*ratio;
    toy=y1+(y2-y1)*ratio;
  }else{
    tox=x2;
    toy=y2;
  }
  if(which&2){
    fromx=x1+(x2-x1)*(1-ratio);
    fromy=y1+(y2-y1)*(1-ratio);
  }else{
    fromx=x1;
    fromy=y1;
  }

  // Draw the shaft of the arrow
  ctx.beginPath();
  ctx.moveTo(fromx,fromy);
  ctx.lineTo(tox,toy);
  ctx.stroke();

  // calculate the angle of the line
  var lineangle=Math.atan2(y2-y1,x2-x1);
  // h is the line length of a side of the arrow head
  var h=Math.abs(d/Math.cos(angle));

  if(which&1){	// handle far end arrow head
    var angle1=lineangle+Math.PI+angle;
    var topx=x2+Math.cos(angle1)*h;
    var topy=y2+Math.sin(angle1)*h;
    var angle2=lineangle+Math.PI-angle;
    var botx=x2+Math.cos(angle2)*h;
    var boty=y2+Math.sin(angle2)*h;
    toDrawHead(ctx,topx,topy,x2,y2,botx,boty,style);
  }
  if(which&2){ // handle near end arrow head
    var angle1=lineangle+angle;
    var topx=x1+Math.cos(angle1)*h;
    var topy=y1+Math.sin(angle1)*h;
    var angle2=lineangle-angle;
    var botx=x1+Math.cos(angle2)*h;
    var boty=y1+Math.sin(angle2)*h;
    toDrawHead(ctx,topx,topy,x1,y1,botx,boty,style);
  }
}


// boundingBox keeps track of the top left and bottom right coordinates of rect
// x, y - coordinate of top left corner
// xextent - width
// yextent - height
function boundingBox(x,y,xextent,yextent)
{
    'use strict';
    this.x1=x;
    this.y1=y;
    this.x2=x+xextent;
    this.y2=y+yextent;
    this.toString=function(){ return 'boundingBox(('+this.x1+','+this.y1+'),('+this.x2+','+this.y2+'))'; }
}

// makes a valiant effort to change an x,y pair from an event to an array of
// size two containing the resultant x,y offset onto the canvas.
// There are events, like key events for which this will not work.  They
// are not mouse events and don't have the x,y coordinates.
function getCanvasCursorPosition(e,canvas)
{
    'use strict';
    var x;
    var y;
    if(e.type=='touchmove'||e.type=='touchstart'||e.type=='touchend'){
	x = e.touches[0].pageX;
	y = e.touches[0].pageY;
    }else if (e.pageX || e.pageY) {
	x = e.pageX;
	y = e.pageY;
    } else {
	x = e.clientX + document.body.scrollLeft +
            document.documentElement.scrollLeft;
	y = e.clientY + document.body.scrollTop +
            document.documentElement.scrollTop;
    }
    // Convert to coordinates relative to the canvas
    x -= canvas.offsetLeft;
    y -= canvas.offsetTop;

    return [x,y]
}

// handy constants
var SLIDER_HORIZONTAL=0;
var SLIDER_VERTICAL=1;
var CVS_BUTTON_DOWN=0;
var CVS_BUTTON_UP=1;
var CVS_BUTTON_NORMAL=0;
var CVS_BUTTON_TOGGLE=1;
var CVS_BUTTON_LEFT_ARROW=2;
var CVS_BUTTON_RIGHT_ARROW=3;

function button(ctx,x,y,width,height,eventmanager,onchange,name,type,state,color)
{
    'use strict';
    var self=this;
    this.eventmanager=eventmanager; // this is the guy that sends us events
    this.ctx=ctx;   // we use this to draw ourselves on the canvas
    this.x=x;	    // top left x,y
    this.y=y;
    this.height=height;
    this.width=width;
    this.onchange=onchange; // Call this when we change
    this.name=name;	    // for debugging
    this.state=typeof(state)!='undefined'?state?CVS_BUTTON_DOWN:CVS_BUTTON_UP:CVS_BUTTON_UP;
    this.type=typeof(type)!='undefined'? type:CVS_BUTTON_NORMAL;
    this.toggle=this.type==CVS_BUTTON_TOGGLE?true:false;
    this.color=typeof(color)!='undefined'?color:'rgba(205,205,205,1)';
    var clrObj=new colorObject(this.color);

    // This is the eventhandler for the button
    // it returns true if we don't consume the event, else
    // returns cancelEvent(e) (which returns false)
    // x,y - canvas relative x and y
    // e - the actual event
    this.getstate=function()
    {
	return self.state;
    }

    this.setstate=function(state)
    {
	var old_state=self.state;
	self.state=typeof(state)!='undefined'?state?CVS_BUTTON_DOWN:CVS_BUTTON_UP:CVS_BUTTON_UP;
	if(old_state!=self.state){
	    self.onchange();
	}
    }

    this.eventhandler=function(x,y,e)
    {
	// at the end if state is still old_state, then we didn't react to the
	// event noticably, so we won't call the onChange handler
	'use strict';
	var old_state=self.state;

	if(e.type=='keydown'){
	    if(e.keyCode==13){
		// <ENTER> key
		if(!self.keyupID){
		    self.keyupID=self.eventmanager.listen('keyup',self.hit,self.eventhandler);
		}
		if(self.toggle){
		    self.state= self.state==CVS_BUTTON_DOWN?
						CVS_BUTTON_UP:CVS_BUTTON_DOWN;
		}else{
		    self.state=CVS_BUTTON_DOWN;
		}
	    }else{
		return true;
	    }
	}else if(e.type=='keyup'){
	    if(e.keyCode==13){
		self.eventmanager.quitlistening('keyup',self.keyupID);
		if(!self.toggle){
		    self.state=CVS_BUTTON_UP;
		}
	    }
	}else if(e.type=='mousedown'){
	    if(self.toggle){
		self.state= self.state==CVS_BUTTON_DOWN?
					    CVS_BUTTON_UP:CVS_BUTTON_DOWN;
	    }else{
		self.state=CVS_BUTTON_DOWN;
	    }
	    // turn on listening to mouseup, mouseclick, mouseout
	    if(!self.mouseupID && !self.toggle){
		self.mouseupID=self.eventmanager.listen('mouseup',self.hit,self.eventhandler);
	    }
	    if(!self.mouseclickID && !self.toggle){
		self.mouseclickID=self.eventmanager.listen('mouseclick',self.hit,self.eventhandler);
	    }
	    if(!self.mouseoutID && !self.toggle){
		// we need to know when the mouse leaves so we can stop 
		// listening for stuff
		self.mouseoutID=self.eventmanager.listen('mouseout',self.hit,self.eventhandler);
	    }
	}else if(e.type == 'mouseup' ||
		  e.type == 'mouseclick' ||
		  e.type == 'mouseout'){
	    if(!self.toggle){
		self.state=CVS_BUTTON_UP;
	    }
	    // any one of these is good for a mouse up, turn them off until
	    // we get another mousedown
	    if(self.mouseupID){
		self.eventmanager.quitlistening('mouseup',self.mouseupID);
		self.mouseupID=null;
	    }
	    if(self.mouseclickID){
		self.eventmanager.quitlistening('mouseclick',self.mouseclickID);
		self.mouseclickID=null;
	    }
	    if(self.mouseoutID){
		self.eventmanager.quitlistening('mouseout',self.mouseoutID);
		self.mouseoutID=null;
	    }
	}
	if(self.state!=old_state){
	    // Only if it changed our state did we really consume it.
	    // call the callback and cancel the event and return
	    self.onchange();
	    return cancelEvent(e);
	}else{
	  // nothing changed, so return true so that someone else gets event
	  return true;
	}
    }

    // This draws our pretty button self.
    this.draw=function()
    {
	'use strict';
	self.ctx.save();    // Make us reentrant
	self.ctx.strokeStyle='rgb(0,0,0)';
	self.ctx.lineWidth=1;

	if(self.type==CVS_BUTTON_NORMAL){
	  // draw a black surrounding line.  Offset by one for 3d
	  ctx.roundedRect(self.x,self.y,self.width-1,self.height-1,2,false,true);
	  self.ctx.strokeStyle='rgb(255,255,255)';
	  // offset by one the other way for 3d effect
	  ctx.roundedRect(self.x+1,self.y+1,self.width,self.height,2,false,true);
	  if(self.state==CVS_BUTTON_DOWN){
	    self.ctx.fillStyle=clrObj.mult(.75);
	    ctx.roundedRect(self.x+1,self.y+1,self.width-3,self.height-3,2,true,false);
	    var grad=ctx.createLinearGradient(self.x+1,self.y+1,self.x+1,self.height-3+self.y);
	    grad.addColorStop(0,'rgba(180,180,180,.6)');
	    grad.addColorStop(.3,'rgba(245,245,245,1.0)');
	    grad.addColorStop(1,'rgba(0,0,0,.5)');
	    ctx.fillStyle=grad;
	    ctx.roundedRect(self.x+1,self.y+1,self.width-3,self.height-3,2,true,false);

	  }else if(self.state==CVS_BUTTON_UP){
	    self.ctx.fillStyle=clrObj.mult(.92);
	    ctx.roundedRect(self.x+2,self.y+2,self.width-4,self.height-4,2,true,false);
	    var grad=ctx.createLinearGradient(self.x+2,self.y+2,self.x+2,self.height+self.y);
	    grad.addColorStop(0,'rgba(255,255,255,1)');
	    grad.addColorStop(1,'rgba(245,245,245,0.0)');
	    ctx.fillStyle=grad;
	    ctx.roundedRect(self.x+2,self.y+2,self.width-4,self.height-4,2,true,false);
	  }
	} else if(self.toggle){
	    ctx.clearRect(self.x,self.y,self.x,self.y);
	    ctx.beginPath();
	    ctx.arc(self.x+.25*self.width,self.y+.5*self.height,7,0,Math.PI*2,false);
	    ctx.strokeStyle='rgb(0,0,0)';
	    ctx.stroke();
	    if(self.state==CVS_BUTTON_DOWN){
		if(self.toggle){
		    ctx.beginPath();
		    ctx.fillStyle='rgb(0,0,0)';
		    ctx.arc(self.x+.25*self.width,self.y+.5*self.height,2,0,Math.PI*2,false);
		    ctx.fill();
		}
	    }
	}
	
	if(self.name){
	    self.ctx.fillStyle='rgb(0,0,0)';
	    var txtwidth=self.ctx.measureText(self.name).width;
	    var y=self.toggle||self.state==CVS_BUTTON_UP?self.y+self.height/2:self.y+self.height/2+1;
	    var x=self.toggle?self.x+.25*self.width+20:self.x+self.width/2-txtwidth/2;
	    ctx.textBaseline='middle';
	    self.ctx.fillText(self.name,x,y);
	}
	self.ctx.restore();
    }

    // an easy way to keep track of us on screen.
    this.bb=new boundingBox(this.x,this.y,this.width,this.height);

    // called from event manager to ask us if an x,y pair is us.  Return true
    // to get whatever event it is.
    this.hit=function(x,y,e){
	'use strict';

	if(x>=self.bb.x1 && x<=self.bb.x2 && y>=self.bb.y1 && y<=self.bb.y2){
	    return true;
	}else{
	    return false;
	}
    }

    // These are the initial events we listen on always
    this.keydown=
	this.eventmanager.listen('keydown',this.hit,self.eventhandler);
    // We'll quit mouse events if we get touch events
    this.mousedownID=
	this.eventmanager.listen('mousedown',this.hit,self.eventhandler);
    this.mouseupID=null;
    this.keyupID=null;
    this.mouseclickID=null;
}

// a class to encapsulate the workings of a slider to be drawn on a canvas
// ctx - canvas context, (assumes 2d), used in draw method
// x,y - canvas relative location of top left
// length - the long measurment, this could be along x or y axis depending 
//	    on whether orientation is horizontal or vertical
// width  - the short measurement
// orientation - one of SLIDER_HORIZONTAL or SLIDER_VERTICAL
// min - the minimum value returned by the slider
// max - the maximum value returned by the slider
// step - how far on click changes value of slider
// value - original value of slider at creation
// eventmanager - who we talk to say that we want to start or stop listening
//	    for particular events
// onchange - a routine we call we our value changes
// name - our name - useful for debugging
function slider(ctx,x, y, length, width, orientation, min, max, step, value,eventmanager,onchange,name)
{
    'use strict';
    var self=this;
    this.eventmanager=eventmanager; // this is the guy that sends us events
    this.ctx=ctx;   // we use this to draw ourselves on the canvas
    this.x=x;	    // top left x,y
    this.y=y;
    this.length=length;	// long way
    this.width=width;	// short way
    this.orientation=orientation;   //vertical or horizontal
    if(min<=max){ this.min=min; this.max=max; }
    else{ this.min=max; this.max=min; }
    this.range=this.max-this.min;
    this.step=step;

    // make sure the value is an even step amount
    var checkValue=function(inval,min,max,step){
	'use strict';
	var val=Math.round(inval);
	val=val-(val % step);
	if(val<min){
	    val=min;
	}else if(val>max){
	    val=max;
	}
	return val;
    }
    this.value=checkValue(value,this.min,this.max,this.step);

    this.onchange=onchange; // Call this when we change
    this.name=name;	    // for debugging

    this.sliderWidth=this.width-2;  // we don't use 1 pixel on each side

    // so our creator can find out.  It's our purpose in life
    this.getValue=function(){
	'use strict';
	return self.value;
    }

    this.setValue=function(newval){
	'use strict';
	var intval=checkValue(parseInt(newval,10),self.min,self.max,self.step);
	if(intval!=self.value){
	    self.value=intval;
	    self.onchange();
	}
    }

    // This is the eventhandler for the slider
    // it returns true if we don't consume the event, else
    // returns cancelEvent(e) (which returns false)
    // x,y - canvas relative x and y
    // e - the actual event
    this.eventhandler=function(x,y,e)
    {
	// at the end if value is still oldvalue, then we didn't react to the
	// event noticably, so we won't call the onChange handler
	'use strict';
	var oldvalue=self.value;

	if(e.type=='keydown'){
	    // we only care about cursor key movement
	    if(e.keyCode==36){
		// <Home> key
		self.value=checkValue(self.min,self.min,self.max,self.step);
	    } else if(e.keyCode==35){
		// <End> key
		self.value=checkValue(self.max,self.min,self.max,self.step);
	    } else if(e.keyCode==33){
		// <Page Up> key
		self.value=checkValue(self.value+2*self.step,self.min,self.max,self.step);
	    } else if(e.keyCode==34){
		// <Page Down> key
		self.value=checkValue(self.value-2*self.step,self.min,self.max,self.step);
	    } else if(e.keyCode>=37 && e.keyCode<=40){
		if(e.keyCode==37 || e.keyCode==39){
		    // <left> or <right>
		    self.value=
			checkValue(self.value+(e.keyCode-38)*self.step,
				self.min,self.max,self.step);
		}else if(e.keyCode==38 || e.keyCode==40){
		    // <up> or <down>
		    self.value=
			checkValue(self.value-(e.keyCode-39)*self.step,
				self.min,self.max,self.step);
		}
		// make sure we're in range
	    }else{
		// don't cancel the event, maybe someone else can use the key
		return true;
	    }
	    // If we get here, we potentially changed something.
	    if(self.value!=oldvalue){
		// if we changed call the onChange callback
		self.onchange();
	    }
	    // we consumed it, so cancel it
	    return cancelEvent(e);
	}else if(e.type=='touchmove'||e.type=='touchstart'||e.type=='touchstart'){
	    // if we get a touch event we cancel all existing mouse listens
	    // because, we only expect touch from now on.
	    if(self.mousedownID){
		self.eventmanager.quitlistening('mousedown',self.mousedownID);
		self.mousedownID=null;
	    }
	    if(self.mousewheelID){
		self.eventmanager.quitlistening('mousewheel',self.mousewheelID);
		self.mousewheelID=null;
	    }
	    if(self.DOMMouseScrollID){
		self.eventmanager.quitlistening('DOMMouseScroll',self.DOMMouseScrollID);
		self.DOMMouseScrollID=null;
	    }
	    if(self.mousemoveID){
		self.eventmanager.quitlistening('mousemove',self.mousemoveID);
		self.mousemoveID=null;
	    }
	    if(self.mouseupID){
		self.eventmanager.quitlistening('mouseup',self.mouseupID);
		self.mouseupID=null;
	    }
	    if(self.mouseclickID){
		self.eventmanager.quitlistening('mouseclick',self.mouseclickID);
		self.mouseclickID=null;
	    }
	    // if we get a touchstart, listen for touchmove and touchend
	    if(e.type=='touchstart'){
		if(self.touchmoveID==null){
		    self.touchmoveID=self.eventmanager.listen('touchmove',self.hit,self.eventhandler);
		}
		if(self.touchendID==null){
		    self.touchendID=self.eventmanager.listen('touchend',self.hit,self.eventhandler);
		}
	    }else if(e.type=='touchend'){
		// They lifted finger, quit listening to touchmove and touchend
	        if(self.touchmoveID){
		    self.eventmanager.quitlistening('touchmove',self.touchmoveID);
		}
	        if(self.touchendID){
		    self.eventmanager.quitlistening('touchend',self.touchendID);
		}
	    }
	}else if(e.type=='DOMMouseScroll' || e.type=='mousewheel'){
	    // simple, just change the value by step in the right direction
	    self.value=checkValue(self.value-wheelDirection(e)*self.step,self.min,self.max,self.step);
	    if(self.value!=oldvalue){
		self.onchange();
	    }
	    return cancelEvent(e);
	}else if(e.type=='mousedown'){
	    // turn on listening to mousemove, mouseup, mouseclick, mouseout
	    if(!self.mousemoveID){
		self.mousemoveID=self.eventmanager.listen('mousemove',self.hit,self.eventhandler);
	    }
	    if(!self.mouseupID){
		self.mouseupID=self.eventmanager.listen('mouseup',self.hit,self.eventhandler);
	    }
	    if(!self.mouseclickID){
		self.mouseclickID=self.eventmanager.listen('mouseclick',self.hit,self.eventhandler);
	    }
	    if(!self.mouseoutID){
		// we need to know when the mouse leaves so we can stop 
		// listening for stuff
		self.mouseoutID=self.eventmanager.listen('mouseout',self.hit,self.eventhandler);
	    }
	}else if(e.type != 'mousemove'){
	    // only other thing we react to now is move, if it's not move
	    // it's mouse up or click or mouseout, turn off listeners
	    if(self.mousemoveID){
		self.eventmanager.quitlistening('mousemove',self.mousemoveID);
		self.mousemoveID=null;
	    }
	    if(self.mouseupID){
		self.eventmanager.quitlistening('mouseup',self.mouseupID);
		self.mouseupID=null;
	    }
	    if(self.mouseclickID){
		self.eventmanager.quitlistening('mouseclick',self.mouseclickID);
		self.mouseclickID=null;
	    }
	    if(self.mouseoutID){
		self.eventmanager.quitlistening('mouseout',self.mouseoutID);
		self.mouseoutID=null;
	    }
	    // hmmm, did we consume that one or not?  It did make us stop
	    // listening, i.e. it was the end of our conversation...guess
	    // it was ours so we'll still cancel
	    return cancelEvent(e);
	}

	// Now we think we're a mousemove
	if(self.orientation===SLIDER_HORIZONTAL){
	    self.value=checkValue(self.min+(self.range)*(x-(self.x+self.sliderWidth/2))/(self.length-self.sliderWidth),self.min,self.max,self.step);
	}else{
	    // orientation is vertical, the y will decide the value
	    self.value=checkValue(self.max-(self.range)*(y-(self.y+self.sliderWidth/2))/(self.length-self.sliderWidth),self.min,self.max,self.step);
	}
	if(self.value!=oldvalue){
	    self.onchange();
	}
    }
    // valueToPos - turns the current value into a pixel offset into the slider
    this.valueToPos=function()
    {
	'use strict';
	if(this.orientation===SLIDER_HORIZONTAL){
	    return (this.length-this.sliderWidth)*((this.value-this.min)/(this.max-this.min))+this.sliderWidth/2;
	}else{
	    return (this.length-this.sliderWidth)*((this.max-this.value)/(this.max-this.min))+this.sliderWidth/2;
	}

    }
    // This draws our pretty slider self.
    this.draw=function()
    {
	'use strict';
	this.ctx.save();    // Make us reentrant
	// set up translation, scaling and rotation so that we can always
	// draw with the same set of commands no matter the orientation of
	// the slider
	this.ctx.translate(this.x,this.y);
	if(this.orientation===this.vertical){
	    ctx.scale(-1,1);
	    ctx.rotate(Math.PI/2);
	}
	// the slider background is a medium grey
	this.ctx.fillStyle="rgba(180,180,180,1)";
	this.ctx.fillRect(0,0,this.length,this.width);
	// highlight bottom and right edges with white
	this.ctx.lineWidth=1.0;
	this.ctx.strokeStyle="rgba(255,255,255,1)";
	this.ctx.beginPath();
	this.ctx.moveTo(0,this.width);
	this.ctx.lineTo(this.length,this.width);
	this.ctx.lineTo(this.length,0);
	this.ctx.stroke();
	// low light top and left edges with black
	this.ctx.strokeStyle="rgba(0,0,0,1)";
	this.ctx.beginPath();
	this.ctx.moveTo(0,this.width);
	this.ctx.lineTo(0,0);
	this.ctx.lineTo(this.length,0);
	this.ctx.stroke();
	// draw ticks with tiny grey circles
	this.ctx.strokeStyle="rgba(90,90,90,1)";
	for(var ctr=0;ctr<=(this.max-this.min);ctr++){
	    var stepxsize=(this.length-this.sliderWidth)/((this.max-this.min)/this.step);
	    this.ctx.beginPath();
	    this.ctx.arc(stepxsize*ctr+this.sliderWidth/2,
		    this.width/2,.5,0,2*Math.PI,true);
	    this.ctx.stroke();
	}
	// Now make the thumb (no it's not dumb - geez, are you three?)
	this.ctx.fillStyle="rgba(230,230,230,1)";
	this.ctx.strokeStyle="rgba(220,220,220,1)";
	var pos=this.valueToPos();
	this.ctx.lineWidth=1.0;
	this.ctx.beginPath();
	this.ctx.arc(pos,this.width/2,this.sliderWidth/2,0,2*Math.PI,false);
	this.ctx.fill();
	this.ctx.stroke();
	// Now make the highlight for the slider
	this.ctx.strokeStyle="rgba(255,255,255,1)";
	this.ctx.beginPath();
	this.ctx.arc(pos,this.width/2,this.sliderWidth/2,0.9*Math.PI,1.60*Math.PI,false);
	this.ctx.stroke();
	// Now make the low-light for the slider
	this.ctx.strokeStyle="rgba(100,100,100,1)";
	this.ctx.beginPath();
	this.ctx.arc(pos,this.width/2,this.sliderWidth/2,.00*Math.PI,0.65*Math.PI,false);
	this.ctx.stroke();
	this.ctx.restore();
    }

    // an easy way to keep track of us on screen.
    if(this.orientation==SLIDER_HORIZONTAL){
	this.bb=new boundingBox(this.x,this.y,this.length,this.width);
    }else{
	this.bb=new boundingBox(this.x,this.y,this.width,this.length);

    }

    // called from event manager to ask us if an x,y pair is us.  Return true
    // to get whatever event it is.
    this.hit=function(x,y,e){
	'use strict';
	if(x>=self.bb.x1 && x<=self.bb.x2 && y>=self.bb.y1 && y<=self.bb.y2){
	    return true;
	}else{
	    return false;
	}
    }

    // These are the initial events we listen on always
    this.keydown=
	this.eventmanager.listen('keydown',this.hit,self.eventhandler);
    // We'll quit mouse events if we get touch events
    this.mousedownID=
	this.eventmanager.listen('mousedown',this.hit,self.eventhandler);
    this.mousewheel=
	this.eventmanager.listen('mousewheel',this.hit,self.eventhandler);
    this.DOMMouseScrollID=
	this.eventmanager.listen('DOMMouseScroll',this.hit,self.eventhandler);
    // The next one turns off the preceeding mouse ones if we receive it
    this.touchstartID=
	this.eventmanager.listen('touchstart',this.hit,self.eventhandler);
    this.touchmoveID=null;
    this.touchendID=null;
    this.mousemoveID=null;
    this.mouseupID=null;
    this.mouseclickID=null;
}

// object used by event manager to keep track of interested parties
function eventListener(id, eventType, hit, callback)
{
    'use strict';
    this.id=id;	// unique sequential id so people can cancel
    this.eventType=eventType;
    this.hit=hit;   // call with x,y to see if they really want it
    this.callback=callback; // pass event to here
    this.toString=function() {
	return 'eventListener('+id+','+eventType+','+hit+','+'callback'+')'; }
}

// eventManager receives events from the browser and passes them on to things
// on the canvas which registered rectangular areas they cared about.
function eventManager(canvasManager)
{
    'use strict';
    var self=this;  // We get called in other context, so remember us
    this.id=0;	    // Bump this by one for each listen
    this.queues=new Object();
    // So far, we only use this to get canvas, so why don't we just pass the
    // canvas?  I suspect that later we might need to get to other parts.
    this.canvasManager=canvasManager;

    // Call this to express an interest in listening to a particular event type
    // eventType - string with something like 'keydown' or 'mousemove'
    // hit - a routine that we can call with an x,y offset on the canvas to
    //	    ask if you're interested in the event.  Returns true if so
    // callback - if hit is true, we call the callback passing it the event
    // returns - the id of the event
    this.listen=function(eventType, hit, callback)
    {
	'use strict';
	var queue=this.queues[eventType];
	if(queue==null){
	    // No one's asked to listen to this yet, make a queue to 
	    // store it in.
	    this.queues[eventType]=new Array();
	    queue=this.queues[eventType];
	}else{
	    // Check to see if it's a duplicate
	    for(var ctr=0;ctr<queue.length;ctr++){
		if(eventType==queue[ctr].eventType
			&& hit==queue[ctr].hit
			&& callback==queue[ctr].callback){
		    alert('duplicate! ctr: '+ctr
			    +' eventType: '+queue[ctr].eventType
			    +' x: '+queue[ctr].boundingbox.x
			    +' y: '+queue[ctr].boundingbox.y
			    +' xextent: '+queue[ctr].boundingbox.xextent
			    +' yextent: '+queue[ctr].boundingbox.yextent);
		    return queue[ctr].id;
		}
	    }
	}
	// If we get down here, we're adding a new eventListener
	queue[queue.length]=new eventListener(this.id,eventType, hit, callback);
	if(queue.length==1){
	    // First thing added to this queue, so start listening for this
	    // event on the canvas
	    hookEvent(this.canvasManager.canvas,eventType,this.eventhandler);
	}
	this.id=this.id+1;  // bump so next listen gets different id
	
	return this.id-1;   // return value before the bump
    }

    // quitlistening is called when we're tired of listening for an event
    // eventType - string with something like 'keydown' or 'mousemove'
    // id - the same id that was returned from listen
    this.quitlistening=function(eventType,id)
    {
	'use strict';
	var queue=this.queues[eventType];
	if(queue==null){
	    // they aren't listening those silly gooses.
	    return;
	}
	for(var ctr=0;ctr<queue.length;ctr++){
	    if(queue[ctr].id==id){
		queue.remove(ctr,ctr);
	    }
	    if(queue.length==0 &&
		    eventType != 'mouseover' && eventType != 'mouseout'){
		// nobody is listening anymore, so we'll quit listening
		// We always listen for mouseover and mouseout though.
		unhookEvent(this.canvasManager.canvas,eventType,this.eventhandler);
	    }
	}
    }

    // eventhandler for eventManager
    // At the global level, as an event goes down through the capture and
    // then back up through the global stage, anyone can stop the 
    // propogation of the event. (Note that I don't allow my children
    // to choose one or the other.  I always ask for bubble events so
    // that's what they get.
    //
    // The W3C DOM2 Event spec, says that even if stopPropagation is 
    // called on an element, that the event will be dispatched to all
    // event listeners on the current element.  So, one interpretation,
    // since all the listeners in my queue are on the same canvas would
    // be for me to keep dispatching.  Another interpretation would have
    // me only dispatch to the same subelement.  We don't allow multiple
    // registers from the same element unless they use different dispatch
    // routines or different hit routines.  If they differ with hit 
    // routines or dispatch routines we do.
    // I completely ignore preventDefault since I don't execute that.
    //
    // Another problem is key events.  Since I use mouse x,y to decide who
    // should receive the event on the canvas, and key events don't have
    // associated x,y values, they never hit, but are passed to whoever has
    // focus.  That means you have to click on something to get it to receive
    // the key events.
    this.eventhandler=function(e)
    {
	'use strict';
	var xy;
	if(!e){
	    var e=window.event;
	}
	self.canvasManager.canvas.focus();
	if(e.type=='mouseout'){
	    self.canvasManager.canvas.blur();
	}

	var xy=getCanvasCursorPosition(e,self.canvasManager.canvas);
	var queue=self.queues[e.type];
	var passon=true;  //  if true we didn't consume the event

	if(queue!=null){
	    for(var ctr=0;ctr<queue.length;++ctr){
		var el=queue[ctr];
		if(el.hit(xy[0],xy[1],e)){
		    // we found someone listening on that part of canvas
		    if(!el.callback(xy[0],xy[1],e)){
			// they consumed it
			passon=false;
		    }
		    if(e.type=='mousedown' || e.type=='touchstart'
			|| e.type=='mousewheel' || e.type=='DOMMouseScroll'
			|| e.type=='touchmove'  || e.type=='touchend'
			|| e.type=='touchdown'  || e.type=='keydown'
			    ){
			// give the focus to whoever gets this event
			self.mousefocusedCB=el.callback;
		    }

		} else if(el.callback==self.mousefocusedCB
		       && (e.type=='mouseup'    || e.type=='mouseout'
			|| e.type=='click'      || e.type=='mousemove'
			|| e.type=='touchmove'  || e.type=='touchend'
			|| e.type=='mousewheel' || e.type=='DOMMouseScroll'
			|| e.type=='keydown')){
		    // if the bounding box didn't match, but they are the
		    // one with mouse focus send it to them anyway.
		    if(!self.mousefocusedCB(xy[0],xy[1],e)){
			// they consumed it
			passon=false;
		    }
		    if(  e.type != 'mousemove' && e.type != 'touchmove'
		      && e.type !='mousewheel' && e.type != 'DOMMouseScroll'
		      && e.type != 'keydown' ){
			// but they lose the focus for anything but movement
			self.mousefocusedCB=null;
		    }
		}
	    }
	}
	// passon is true if we didn't cancel, else false
	return passon;
    }
    // we always listen for mouseout and mouseover
    hookEvent(this.canvasManager.canvas,'mouseout',this.eventhandler);
    hookEvent(this.canvasManager.canvas,'mouseover',this.eventhandler);
}

function Clock(id)
{
  var clockcanvas=document.getElementById(id);
  var ctx=clockcanvas.getContext('2d');
  var pi=Math.PI;	            // just for convenience
  this.now;		            // so we know what time it is.
  var xc=clockcanvas.width/2;	    // x center of clock
  var yc=clockcanvas.height/2;      // y center of clock
  var radius=Math.min(.85*xc,.85*yc); // size of the radius of the circle 
  var fontsize=radius/3;


  this.start=function()
  {
    setInterval(this.drawclock,1000);  // 1000ms is 1 sec
  }

  var drawbody=function()
  {
    ctx.save();
    // Shadows from the clock itself
    ctx.shadowOffsetX=Math.max(.04*radius,1);
    ctx.shadowOffsetY=Math.max(.04*radius,1);
    ctx.shadowBlur=Math.max(.04*radius,1);
    ctx.shadowColor='rgba(0,0,0,.2)';
    ctx.beginPath();
    ctx.arc(xc,yc,radius,0,2*pi,false);   // border of clock
    ctx.fillStyle='rgb(255,255,180)';	  // sort of a grey orange background
    ctx.fill();				  // fill first
    ctx.strokeStyle='rgb(30,110,30)';
    ctx.lineWidth=Math.max(radius/5,1);
    ctx.stroke();			  // and then stroke
    ctx.strokeStyle='rgb(70,150,80)';
    ctx.lineWidth=Math.max(radius/15,1);
    ctx.stroke();			  // and then stroke
    ctx.restore();
  }

  var drawback=function()
  {
    ctx.save();
    // draw a dark circle in middle, later after the hands are drawn we'll
    // add a smaller golden circle in the middle
    ctx.beginPath();
    ctx.moveTo(xc,yc);
    
    ctx.arc(xc,yc,Math.max(.03*radius,1),0,2*pi,false);
    ctx.stroke();

    // Now we'll draw the minute and second marks
    ctx.beginPath();
    for(var ctr=0; ctr<60;ctr++){
      var angle=ctr*2*pi/60;
      var x1=(.9*radius)*Math.cos(angle)+xc;
      var y1=(.9*radius)*Math.sin(angle)+yc;
      var x2=(.95*radius)*Math.cos(angle)+xc;
      var y2=(.95*radius)*Math.sin(angle)+yc;
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.lineWidth=1;
      ctx.stroke();
    }

    // Next are the fatter longer hour marks
    ctx.beginPath();
    ctx.lineWidth=Math.max(.05*radius,1);
    for(var ctr=0; ctr<12;ctr++){
      var angle=ctr*2*pi/12;
      var x1=(.8*radius)*Math.cos(angle)+xc;
      var y1=(.8*radius)*Math.sin(angle)+yc;
      var x2=(.95*radius)*Math.cos(angle)+xc;
      var y2=(.95*radius)*Math.sin(angle)+yc;
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
    }

    // Next we draw the hour numbers.  We start at 3 because that 
    // corresponds to 0 degrees
    var hours=['3','4','5','6','7','8','9','10','11','12','1','2'];
    ctx.font = fontsize+"px Times,'Times New Roman',sans-serif";
    ctx.textBaseline='middle';
    for(var ctr=0;ctr<12;ctr++){
	var angle=ctr*2*pi/12;
	var len=.5*radius;
	// we adust the x with an equation using cosine and the y with
	// an equation using sin so that the text looks like it's in an
	// even circle
	var x=len*Math.cos(angle)+xc-((1-Math.cos(angle))/2)*ctx.measureText(hours[ctr]).width;
	var y=len*Math.sin(angle)+yc+fontsize/3*Math.sin(angle);
	ctx.fillText(hours[ctr],x,y);
    }
    ctx.restore();
  }

  var drawhands=function()
  {
    ctx.save();
    ctx.shadowBlur=Math.max(.04*radius,1);

    // Make a shadow for the center staff that the hands can be drawn on
    ctx.fillStyle='rgb(100,80,40,0)';
    for(var ctr=0;ctr<Math.max(.07*radius,1);ctr+=.1){
	ctx.shadowColor='rgba(0,0,0,.01)';
	ctx.beginPath();
	ctx.shadowOffsetX=ctr;
	ctx.shadowOffsetY=ctr;
	ctx.arc(xc,yc,Math.max(.04*radius,1),0,2*pi,false);
	ctx.fill();
    }

    ctx.shadowColor='rgba(0,5,0,.5)';

    // Now the hour hand, first a skinnier front hand
    ctx.fillStyle='rgb(0,0,0)';
    ctx.shadowOffsetX=Math.max(.03*radius,1);
    ctx.shadowOffsetY=Math.max(.03*radius,1);
    var hourangle=3*pi/2+(2*pi/12)*(self.now.getHours()+self.now.getMinutes()/60);
    var hourx=(.5*radius)*Math.cos(hourangle)+xc;
    var houry=(.5*radius)*Math.sin(hourangle)+yc;
    ctx.lineWidth=Math.max(.03*radius,1);
    drawArrow(ctx,xc,yc,hourx,houry,3,1,Math.PI/4,.15*radius);
    // and the heavier back end
    var hourx=.2*radius*Math.cos(hourangle+pi)+xc;
    var houry=.2*radius*Math.sin(hourangle+pi)+yc;
    ctx.beginPath()
    ctx.moveTo(xc,yc);
    ctx.lineWidth=Math.max(.06*radius,1);
    ctx.lineTo(hourx,houry);
    ctx.stroke();

    ctx.shadowOffsetX=Math.max(.05*radius,1);
    ctx.shadowOffsetY=Math.max(.05*radius,1);

    // draw the minute hand we draw the front pointer part first,
    // then add a back heavier part
    var minuteangle=3*pi/2+(2*pi/60)*self.now.getMinutes();
    var minx=(.85*radius)*Math.cos(minuteangle)+xc;
    var miny=(.85*radius)*Math.sin(minuteangle)+yc;
    ctx.lineWidth=Math.max(.03*radius,1);// set up lineWidth for the drawArrow
    drawArrow(ctx,xc,yc,minx,miny,3,1,Math.PI/4,.2*radius);
    // Now the back heavier part
    var minx=.25*radius*Math.cos(minuteangle+pi)+xc;
    var miny=.25*radius*Math.sin(minuteangle+pi)+yc;
    ctx.beginPath();
    ctx.moveTo(xc,yc);
    ctx.lineWidth=Math.max(.06*radius,1);
    ctx.lineTo(minx,miny);
    ctx.stroke();

    // Second hand, red, same story, skinny front part first
    ctx.shadowOffsetX=Math.max(.07*radius,1);
    ctx.shadowOffsetY=Math.max(.07*radius,1);
    ctx.fillStyle='rgb(255,0,0)';
    ctx.strokeStyle='rgb(255,0,0)';
    var secondangle=3*pi/2+(2*pi/60)*self.now.getSeconds();
    var secx=(.75*radius)*Math.cos(secondangle)+xc;
    var secy=(.75*radius)*Math.sin(secondangle)+yc;
    ctx.lineWidth=1.01;
    drawArrow(ctx,xc,yc,secx,secy,3,1,Math.PI/20,.22*radius);
    // thicker back part later
    var secx=.25*radius*Math.cos(secondangle+pi)+xc;
    var secy=.25*radius*Math.sin(secondangle+pi)+yc;
    ctx.beginPath();
    ctx.moveTo(xc,yc);
    ctx.lineWidth=Math.max(.04*radius,1);
    ctx.lineTo(secx,secy);
    ctx.stroke();

    // draw the center of the clock
    ctx.fillStyle='rgb(100,80,40)';
    ctx.beginPath();
    ctx.arc(xc,yc,Math.max(.04*radius,1),0,2*pi,false);
    ctx.fill();

    ctx.restore();
    ctx.beginPath();
    ctx.moveTo(xc,yc);
    ctx.fillStyle='rgb(255,255,0)';
    ctx.arc(xc,yc,Math.max(.03*radius,1),0,2*pi,false);
    ctx.fill();
  }

  var drawhighlights=function()
  {
    ctx.save();
    // draw a highlight around the edge of the glass
    // Note the alpha so everything shows through it
    ctx.shadowOffsetX=Math.max(.05*radius,1);
    ctx.shadowOffsetY=Math.max(.05*radius,1);
    ctx.shadowBlur=Math.max(.08*radius,1);
    ctx.shadowColor='rgba(0,0,0,.5)';
    ctx.strokeStyle='rgba(255,255,255,.40)';
    ctx.lineWidth=Math.max(.1*radius,1);
    ctx.beginPath();
    ctx.arc(xc,yc,.9*radius,0,2*pi,false);
    ctx.stroke();

    // then a skinnier highlight inside the other
    // Note the alpha is higher so you can barely see through it
    ctx.strokeStyle='rgba(255,255,255,.45)';
    ctx.lineWidth=Math.max(.03*radius,1);
    ctx.beginPath();
    ctx.arc(xc,yc,.90*radius,0,2*pi,false);
    ctx.stroke();

    // then a highlight in the center of the glass
    // the alpha makes it barely there
    ctx.beginPath();
    var grad=ctx.createRadialGradient(xc+.1*radius,yc-.3*radius,10,xc,yc,radius);
    grad.addColorStop(0,'rgba(255,255,255,.2)');
    grad.addColorStop(.01,'rgba(255,255,255,.1)');
    grad.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle=grad;
    ctx.arc(xc,yc,radius,0,2*pi,false);
    ctx.fill();
    ctx.restore();
  }

  this.drawclock=function()
  {
    ctx.save();
    this.now=new Date();

    // got to clear it each time through or the hands smear
    ctx.clearRect(0,0,clockcanvas.width,clockcanvas.height);

    // default our stroke and fill styles
    ctx.strokeStyle='rgb(0,0,0)';
    ctx.fillStyle='rgb(0,0,0)';
    ctx.shadowOffsetX=0;
    ctx.shadowOffsetY=0;
    ctx.shadowBlur=0;
    ctx.shadowColor='rgba(0,0,0,0)';

    // next draw the background and border of the clock
    drawbody();
    drawback();
    drawhands();
    drawhighlights();
    

    // Turn off all shadows
    /*
    ctx.shadowOffsetX=0;
    ctx.shadowOffsetY=0;
    ctx.shadowBlur=0;
    ctx.shadowColor='rgba(0,0,0,0)';
    */
    delete this.now;
  }
}

;Base_Help = function(){
	this.compatibility_mode = null;
	this.pointerX = 0;
	this.pointerY = 0;
	this.context;
	this.step = 0;
	this.steps;
	this.suspended = 0;
	this.current_step;
	this.target;
	this.operation;
	this.help_hooks;
	this.click_icon = $("Base_Help__click_icon");
	this.help_arrow = $("Base_Help__help_arrow");
	this.comment_frame = $("Base_Help__help_comment");
	this.screen = '';
	this.last_keypress = 0;
	this.trigger_search = false;
	this.prompt_next_step = false;

	this.init_help = function() {
		this.check_compatibility();
		Helper.timed_update();
		Event.observe(document, "mousemove", Helper.update);
	}

	this.check_compatibility = function() {
		var has_pointerevents = jQuery("#help_canvas").css('pointer-events');
		if (has_pointerevents=='auto') {
			jQuery("#help_canvas").css('pointer-events', 'none');
			this.context = $("help_canvas").getContext("2d");
			this.compatibility_mode = false;
            jQuery("#help_canvas").hide();
		} else {
			jQuery("#help_canvas").remove();
			this.compatibility_mode = true;
		}
	}
	
	this.start_tutorial = function(steps) {
		this.step = 0;
		this.steps = steps.split('##');
		for (var i=0;i<this.steps.length; i++)
			this.steps[i] = this.parse_step(i);
		this.hide_menu();
        jQuery("#help_canvas").show();
	}

	this.clear_screen = function () {
		if (!this.compatibility_mode)
			this.context.clearRect(0,0,3000,3000);
	}

	this.stop_tutorial = function() {
        jQuery("#help_canvas").hide();
		$('Base_Help__overlay').style.display = 'none';
		this.help_arrow.style.display = 'none';
		this.comment_frame.style.display = 'none';
		this.step = 0;
		this.steps = 0;
		Helper.clear_screen();
	}

	this.refresh_step = function() {
		this.current_step = this.steps[this.step];
		this.target = this.get_step_target(this.step);
		if (this.target) Event.observe(this.target, 'click', function(){Helper.prompt_next_step = true;});
		this.operation = this.current_step.operation;
		this.screen = jQuery('.Base_Help__screen_name').attr('value');
	}
	this.parse_step = function(step) {
		var res = new Array();
		var tmp = this.steps[step].split(':');
		res.operation = tmp[0];
		if (res.operation[res.operation.length-1] == '?') {
			res.optional = true;
			res.operation = res.operation.substr(0, res.operation.length-1);
		}
		tmp = tmp[1].split('//');
		if (tmp[1]) res.comment = tmp[1];
		tmp = tmp[0].split('->');
		if (tmp[1]) {
			res.target = tmp[1].trim();
			res.screen = tmp[0].trim();
		} else {
			res.target = tmp[0].trim();
			res.screen = '';
		}
		return res;
	}
	this.is_screen = function(step) {
		var step = this.steps[step];
		if (!step) return;
		return (!step.screen || step.screen==this.screen);
	}
	this.get_step_target = function(step) {
		var step = this.steps[step];
		return this.get_help_element(step.target);
	}
	this.timed_update = function() {
		Helper.update();
		setTimeout('Helper.timed_update();', 300);
	}
	this.operation_complete = function() {
		if (this.operation=='click') {
			return this.prompt_next_step;
		}
		if (this.operation=='prompt' || this.operation=='finish') {
			if (this.prompt_next_step) {
				this.prompt_next_step = false;
				if (this.operation=='finish') {
					Helper.stop_tutorial();
				}
				return true;
			}
			return false;
		}
		if (this.operation=='fill') {
			if (!this.target || !this.target.value) return false;
			current = new Date().getTime();
			if ((current - this.last_keypress)<800) return false;
			return true;
		}
		return true;
	}
	this.update = function(e) {
		current = new Date().getTime();
		if (this.trigger_search && (current - this.last_keypress)>800) this.search($('Base_Help__search').value);
		
		if (Helper.compatibility_mode===false)
			jQuery("#help_canvas").css('pointer-events', 'none');
		if (!Helper.steps) return;
		if (typeof(e)=='undefined' && typeof(event)!='undefined') e = event;
		if (typeof(e)!='undefined') {
			Helper.pointerX=e.clientX;
			Helper.pointerY=e.clientY;
		}
		Helper.clear_screen();
		var current = new Date().getTime();
		Helper.click_icon.src = Helper.click_icon.getAttribute('frame'+(current%1000<500?1:2));
		if (Epesi.procOn) {
			Helper.suspended = current+1000;
			Helper.click_icon.style.display = 'none';
		}
		Helper.refresh_step();
		if (!Helper.steps) return;
		while (Helper.operation_complete() && Helper.steps[Helper.step+1] && ((Helper.is_screen(Helper.step+1) && is_visible(Helper.get_step_target(Helper.step+1))) || Helper.steps[Helper.step+1].optional)) {
			Helper.prompt_next_step = false;
			Helper.step += 1;
			while (Helper.steps[Helper.step+1] && Helper.steps[Helper.step].optional)
				Helper.step += 1;
			Helper.refresh_step();
		}
		while(current>=Helper.suspended && Helper.step>0 && (!Helper.is_screen(Helper.step) || !is_visible(Helper.target))) {
			Helper.step -= 1;
			Helper.refresh_step();
		} 
		if (!Epesi.procOn && Helper.target && Helper.is_screen(Helper.step)) {
			Helper.draw_help_arrow(Helper.target);
		}
	}
	this.escape = function() {
		if ($('Base_Help__menu').style.display=="block") this.hide_menu();
		else if (Helper.steps) {
			if (this.steps[this.step].operation == 'finish') this.stop_tutorial();
			else {
				this.steps[this.step].operation = 'finish';
				this.steps[this.step].comment = this.stop_tutorial_message;
			}
		}
	}
	this.menu = function () {
		this.stop_tutorial();
		$('Base_Help__overlay').style.display="block";
		$('Base_Help__menu').style.display="block";
		$('Base_Help__search').value='';
		this.trigger_search = true;
		this.search();
		focus_by_id('Base_Help__search');
	}
	this.document_keydown = function() {
		Helper.last_keypress = new Date().getTime();
	}
	this.search_keypress = function() {
		this.last_keypress = new Date().getTime();
		this.trigger_search = true;
	}
	this.search = function(value) {
		this.trigger_search = false;
		if (!value) {
			$('Base_Help__help_suggestions').style.display='block';
			$('Base_Help__help_links').style.display='none';
			new Ajax.Request('modules/Base/Help/suggestions.php', { 
				method: 'post', 
				parameters:{
					cid: Epesi.client_id
				},
				onComplete: function(t) {
					eval(t.responseText);
				}
			});
		} else {
			$('Base_Help__help_suggestions').style.display='none';
			$('Base_Help__help_links').style.display='block';
			new Ajax.Request('modules/Base/Help/search.php', { 
				method: 'post', 
				parameters:{
					cid: Epesi.client_id,
					keywords: value
				},
				onComplete: function(t) {
					eval(t.responseText);
				}
			});
		}
	}

	this.hide_menu = function () {
		$('Base_Help__overlay').style.display="none";
		$('Base_Help__menu').style.display="none";
	}

	this.get_help_element = function (helpid) {
		if (typeof(this.hooks[helpid])!='undefined') return this.hooks[helpid];
		return jQuery(helpid)[0];
	}

	this.get_all_help_hooks = function() {
		$('Base_Help__button_next').onclick = function(){Helper.prompt_next_step = true;};
		$('Base_Help__button_finish').onclick = function(){Helper.prompt_next_step = true;};
		Helper.hooks = new Array();
		jQuery('[helpID]').each(function(){Helper.hooks[jQuery(this).attr('helpID')] = this});
		return;
	}

	this.draw_help_arrow = function (el) {
		var offset = el.getBoundingClientRect();
		var centerX = (offset.left + offset.right) / 2;
		var centerY = (offset.top + offset.bottom) / 2;
		var width = offset.right - offset.left;
		var height = offset.bottom - offset.top;
		var o_right = offset.right - width/5;
		var o_left = offset.left + width/5;
		var o_bottom = offset.bottom - height/5;
		var o_top = offset.top + height/5;
		if (centerX==0 && centerY==0) return;
		var targetX = centerX;
		var targetY = centerY;
		var sourceX = this.pointerX;
		var sourceY = this.pointerY;
		if (this.pointerX>=o_left && this.pointerX<=o_right) targetX = this.pointerX;
		else if (this.pointerX<o_left) targetX = o_left;
		if (this.pointerX>o_right) targetX = o_right;
		if (this.pointerY>=o_top && this.pointerY<=o_bottom) targetY = this.pointerY;
		else if (this.pointerY<o_top) targetY = o_top;
		if (this.pointerY>o_bottom) targetY = o_bottom;
		var show_click = false;
		if (this.operation=='finish') {
			$('Base_Help__overlay').style.display = 'block';
			$('Base_Help__button_finish').style.display = 'block';
			$('Base_Help__button_next').style.display = 'none';
			this.help_arrow.style.display = "none";
			o_right = (window.innerWidth - this.comment_frame.scrollWidth)/2 - 50;
			o_bottom = (window.innerHeight - this.comment_frame.scrollHeight)/2 - 10;
			targetX = o_right;
			targetY = o_bottom;
			sourceX = targetX+50;
			sourceY = targetY+100;
		} else if (this.operation=='prompt') {
			$('Base_Help__button_next').style.display = 'block';
			$('Base_Help__button_finish').style.display = 'none';
			targetX = o_right;
			targetY = o_bottom;
			sourceX = targetX+50;
			sourceY = targetY+100;
		} else {
			$('Base_Help__button_next').style.display = 'none';
			$('Base_Help__button_finish').style.display = 'none';
			if ((this.pointerX>=offset.left && this.pointerX<=offset.right && this.pointerY>=offset.top && this.pointerY<=offset.bottom) || this.compatibility_mode || (this.operation=='fill' && this.target==document.activeElement)) {
				targetX = o_right;
				targetY = o_bottom;
				sourceX = o_right+15;
				sourceY = o_bottom+15;
				if (this.operation=='click' || (this.operation=='fill' && this.target!=document.activeElement)) {
					this.click_icon.style.left = sourceX+'px';
					this.click_icon.style.top = sourceY+'px';
					show_click = true;
				}
			}
		}
		if (show_click) this.click_icon.style.display="block";
		else this.click_icon.style.display="none";
		if (this.operation!='finish') {
			if (!this.compatibility_mode)
				this.fancy_arrow(this.context, sourceX, sourceY, targetX, targetY);
			else {
				this.help_arrow.style.display = "block";
				this.help_arrow.style.left = targetX+'px';
				this.help_arrow.style.top = targetY+'px';
			}
		}
		if (this.steps[this.step].comment && (this.operation!='fill' || this.target==document.activeElement)) {
			$('Base_Help__help_comment_contents').innerHTML = this.steps[this.step].comment;
			this.comment_frame.style.display = 'block';
			this.comment_frame.style.left = (o_right+50)+'px';
			this.comment_frame.style.top = (o_bottom+10)+'px';
		} else {
			this.comment_frame.style.display = 'none';
		}
	}
	this.fancy_arrow = function(ctx,x1,y1,x2,y2) {
		'use strict';
		ctx.fillStyle = 'rgba(240, 90, 0, 0.8)';

		var angle = 0.45;
		var d    = 40;
		var dist=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
		var ratio=(dist-d/3)/dist;
		var tox, toy,fromx,fromy;
		tox=x1+(x2-x1)*ratio;
		toy=y1+(y2-y1)*ratio;

		var lineangle=Math.atan2(y2-y1,x2-x1);
		var h=Math.abs(d/Math.cos(angle));

		// Arrow shaft
		if (dist>d) {
			var angle = 20/dist;
			var d    = dist;
			var lineangle=Math.atan2(y2-y1,x2-x1);
			var h=Math.abs(d/Math.cos(angle));
			var angle1=lineangle+Math.PI+angle;
			var topx=x2+Math.cos(angle1)*h;
			var topy=y2+Math.sin(angle1)*h;
			var angle2=lineangle+Math.PI-angle;
			var botx=x2+Math.cos(angle2)*h;
			var boty=y2+Math.sin(angle2)*h;
			var curx=x2-Math.cos(lineangle)*(h-30);
			var cury=y2-Math.sin(lineangle)*(h-30);

			var angle = 0.20;
			var d    = 30;
			var h=Math.abs(d/Math.cos(angle));
			var angle1=lineangle+Math.PI+angle;
			var topx2=x2+Math.cos(angle1)*h;
			var topy2=y2+Math.sin(angle1)*h;
			var angle2=lineangle+Math.PI-angle;
			var botx2=x2+Math.cos(angle2)*h;
			var boty2=y2+Math.sin(angle2)*h;
			
			ctx.save();
			ctx.beginPath();
			ctx.moveTo(topx,topy);
			ctx.lineTo(topx2,topy2);
			ctx.lineTo(botx2,boty2);
			ctx.lineTo(botx,boty);
			ctx.quadraticCurveTo(curx,cury,topx,topy);
			ctx.arc(curx, cury, 6, 0 , 2 * Math.PI, false);
			ctx.fill();
		}

		// Arrow ending
		var angle = 0.45;
		var d    = 40;
		var dist=Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));

		var lineangle=Math.atan2(y2-y1,x2-x1);
		var h=Math.abs(d/Math.cos(angle));

		var angle1=lineangle+Math.PI+angle;
		var topx=x2+Math.cos(angle1)*h;
		var topy=y2+Math.sin(angle1)*h;
		var angle2=lineangle+Math.PI-angle;
		var botx=x2+Math.cos(angle2)*h;
		var boty=y2+Math.sin(angle2)*h;
		drawHead(ctx,topx,topy,x2,y2,botx,boty,3);

//		ctx.shadowColor = '#777';
//		ctx.shadowBlur = 12;
//		ctx.shadowOffsetX = 7;
//		ctx.shadowOffsetY = 7;
	}
}

var Helper = new Base_Help();
Helper.init_help();
document.onkeydown = Helper.document_keydown;


;full_screen = function(URL) {
   //window.open(URL,"","fullscreen,scrollbars");
   var width = screen.width;
   var height = screen.height;
   win = window.open(URL, 'epesi', 'fullscreen=yes, scrollbars, menubar=no, toolbar=no, location=no, directories=no, resizable=yes, status=no, left=0, top=0, width=' + width + ', height=' + height);
   win.focus();
}
